{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This module contains the RunTool class which is used to run any tool  with the given arguments \b class RunTool:     Attributes:         tool (str): tool name         script (str): script name         args (list strings): list of arguments \b     Methods:         get_opts(self): get the options of the tool         run(self): run formal verification tool on the given script</p> <p>This module contains a class that defines custom errors for the yaml-to-tcl package.</p> <p>This module contains the TclGen class that generates TCL files from YAML files.</p> <p>This module contains a class \"TclGenVcf\" which can be used to generate a TCL file for VCF. The class takes a dictionary and a file name (for TCL file) as input and generates a TCL file for VCF.</p> <p>This module contains the Utils class that defines some utility functions.</p>"},{"location":"reference/#afgi.run_tools.run.RunTool","title":"<code>RunTool</code>","text":"<p>RunTool class Attributes:     tool (str): tool name     script (str): script name     args (list strings): list of arguments</p> Source code in <code>src/afgi/run_tools/run.py</code> <pre><code>class RunTool:\n    \"\"\" RunTool class\n    Attributes:\n        tool (str): tool name\n        script (str): script name\n        args (list strings): list of arguments\n    \"\"\"\n    def __init__(self, tool, script, args):\n        self.tool = tool\n        self.script = script\n        self.args = args\n\n    def get_opts(self):\n       \"\"\"A method to get the options of the tool\n        Args:\n              None\n        Returns: \n            opts (str): tool options with prefix '-' if not present separated by space  \n       \"\"\"\n       opts = \"\"\n       for arg in self.args:\n            if arg.startswith('-'):\n                opts = opts + ' ' + arg.lower()\n            else:\n                opts = opts + ' ' +'-' + arg.lower()\n       return opts\n\n    # Run formal verification tool on the given script\n    def run(self):\n        \"\"\" A method to run a tool on the given script with the given arguments\n        Args:\n            None\n        Returns:\n            output (str): output of the tool to the console\n        \"\"\"\n\n        # run tool\n        # return os.system(self.tool + ' ' + self.get_opts() + ' ' + self.script)\n        print (self.tool + ' ' + self.get_opts() + ' ' + self.script)\n        res = os.system(self.tool + ' ' + self.get_opts() + ' ' + self.script)\n        return res\n</code></pre>"},{"location":"reference/#afgi.run_tools.run.RunTool.get_opts","title":"<code>get_opts()</code>","text":"<p>A method to get the options of the tool Args:       None Returns:      opts (str): tool options with prefix '-' if not present separated by space</p> Source code in <code>src/afgi/run_tools/run.py</code> <pre><code>def get_opts(self):\n   \"\"\"A method to get the options of the tool\n    Args:\n          None\n    Returns: \n        opts (str): tool options with prefix '-' if not present separated by space  \n   \"\"\"\n   opts = \"\"\n   for arg in self.args:\n        if arg.startswith('-'):\n            opts = opts + ' ' + arg.lower()\n        else:\n            opts = opts + ' ' +'-' + arg.lower()\n   return opts\n</code></pre>"},{"location":"reference/#afgi.run_tools.run.RunTool.run","title":"<code>run()</code>","text":"<p>A method to run a tool on the given script with the given arguments Args:     None Returns:     output (str): output of the tool to the console</p> Source code in <code>src/afgi/run_tools/run.py</code> <pre><code>def run(self):\n    \"\"\" A method to run a tool on the given script with the given arguments\n    Args:\n        None\n    Returns:\n        output (str): output of the tool to the console\n    \"\"\"\n\n    # run tool\n    # return os.system(self.tool + ' ' + self.get_opts() + ' ' + self.script)\n    print (self.tool + ' ' + self.get_opts() + ' ' + self.script)\n    res = os.system(self.tool + ' ' + self.get_opts() + ' ' + self.script)\n    return res\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame","title":"<code>MyFrame</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A class to create the main window of the application</p> <p>Attributes:</p> Name Type Description <code>parent</code> <code>Frame</code> <p>parent frame</p> <code>title</code> <code>str</code> <p>title of the frame</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>class MyFrame(wx.Frame):\n    \"\"\"A class to create the main window of the application\n\n    Attributes:\n        parent (wx.Frame): parent frame\n        title (str): title of the frame \n    \"\"\"\n    def __init__(self, parent, title):\n        wx.Frame.__init__(self, parent, title=title, size=wx.Size(800,600), style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL)\n        dirname = os.path.dirname(__file__)\n        filename = os.path.join(dirname, 'icons/tool_icon.png')\n        self.SetIcon(wx.Icon(filename, wx.BITMAP_TYPE_ANY))\n\n        # Setting up the splitter window.\n        splitter = wx.SplitterWindow(self, -1)\n        self.mainPanel = wx.Panel(splitter, -1, style=wx.DOUBLE_BORDER)\n        self.mainPanel.SetBackgroundColour(\"white\")\n        self.nb = wx.Notebook(self.mainPanel, size=wx.Size(800,600))\n        self.nb_changed = False\n        self.panel2 = wx.Panel(splitter, -1, style=wx.DOUBLE_BORDER)\n        self.panel2.SetBackgroundColour(\"cream\")\n        splitter.SplitVertically(self.mainPanel, self.panel2)\n        self.log = wx.TextCtrl(self.panel2, -1, size=(800, 600), style=wx.TE_MULTILINE|wx.TE_READONLY|wx.HSCROLL)\n        self.redir = RedirectText(self.log)\n        #-----------------Default names-----------------#\n        self.dirname = '.'\n        self.filename = 'Untitled'\n        #------------------------------------------------#\n\n        # Creating the menubar.\n        menu_bar = wx.MenuBar()\n        # Adding the MenuBar to the Frame content.\n        self.SetMenuBar(menu_bar)  \n        # Setting up file menu.\n        file_menu= wx.Menu()\n        menu_bar.Append(file_menu, \"&amp;File\") # Adding the \"file_menu\" to the MenuBar\n        # Create and add menu items to the file menu\n        file_menu_labels = [\"&amp;New\\tCtrl+N\", \"&amp;Open\\tCtrl+O\", \"&amp;Save\\tCtrl+S\", \"&amp;Save As\\tAlt+S\", \"&amp;Exit\\tCtrl+Q\"]  \n        file_menu_item_ids = [wx.ID_NEW, wx.ID_OPEN, wx.ID_SAVE, wx.ID_SAVEAS, wx.ID_EXIT]\n        file_menu_descs = [\"Create new file\", \"Open existing file\", \"Save the current file\", \"Save the file with a different name\", \"Exit the application\"]\n        file_menu_items = []\n        for id, label, desc in itertools.zip_longest(file_menu_item_ids, file_menu_labels, file_menu_descs):\n            file_menu_item = wx.MenuItem(file_menu, id, label, desc, wx.ITEM_NORMAL)\n            file_menu_items.append(file_menu_item)\n            file_menu.Append(file_menu_item)           \n        # Setting up event handlers for the file menu items.\n        file_menu_events = ['OnNew', 'OnOpen', 'OnSave', 'OnSaveAs', 'OnExit']\n        for e, item in zip(file_menu_events, file_menu_items):\n            event = getattr(self, e)\n            self.Bind(wx.EVT_MENU, event, item)     \n        # Setting up Edit menu.\n        edit_menu= wx.Menu()\n        menu_bar.Append(edit_menu,\"&amp;Edit\") # Adding the \"edit_menu\" to the MenuBar\n        # create and add menu items to the edit menu\n        edit_menu_labels = [\"&amp;Undo\\tCtrl+Z\", \"&amp;Redo\\tCtrl+Y\", \"&amp;Cut\\tCtrl+X\", \"&amp;Copy\\tCtrl+C\", \"&amp;Paste\\tCtrl+V\", \"&amp;Delete\\tDel\", \"&amp;Select All\\tCtrl+A\"]\n        edit_menu_item_ids = [wx.ID_UNDO, wx.ID_REDO, wx.ID_CUT, wx.ID_COPY, wx.ID_PASTE, wx.ID_DELETE, wx.ID_SELECTALL]\n        edit_menu_descs = [\"To undo the last action\", \"To redo the last action\", \"To cut the selected text\", \"To copy the selected text\", \"To paste the copied text\", \"To delete the selected text\", \"To select all the text\"]\n        edit_menu_items = []\n        for id, label, desc in itertools.zip_longest(edit_menu_item_ids, edit_menu_labels, edit_menu_descs):\n            edit_menu_item = wx.MenuItem(edit_menu, id, label, desc, wx.ITEM_NORMAL)\n            edit_menu_items.append(edit_menu_item)\n            edit_menu.Append(edit_menu_item)\n        # Setting up event handlers for the edit menu items.\n        edit_menu_events = ['OnUndo', 'OnRedo', 'OnCut', 'OnCopy', 'OnPaste', 'OnDelete', 'OnSelectAll']\n        for e, item in zip(edit_menu_events, edit_menu_items):\n            event = getattr(self, e)\n            self.Bind(wx.EVT_MENU, event, item)\n        # Setting up View menu.\n        view_menu= wx.Menu()\n        menu_bar.Append(view_menu,\"&amp;View\") # Adding the \"view_menu\" to the MenuBar\n        # view_menu_labels = [\"&amp;Zoom In\\tCtrl++\", \"&amp;Zoom Out\\tCtrl+-\", \"&amp;Reset Zoom\\tCtrl+0\", \"&amp;View TCL\\tCtrl+T\"]\n        view_menu_labels = [\"&amp;View TCL\\tCtrl+T\"]\n        # view_menu_item_ids = [wx.ID_ZOOM_IN, wx.ID_ZOOM_OUT, wx.ID_ZOOM_100, wx.ID_PREVIEW]\n        view_menu_item_ids = [wx.ID_PREVIEW]\n        # view_menu_descs = [\"To zoom in the text\", \"To zoom out the text\", \"To reset the zoom\", \"Generate and view the TCL file\"]\n        view_menu_descs = [\"Generate and view the TCL file\"]\n        view_menu_items = []\n        for id, label, desc in itertools.zip_longest(view_menu_item_ids, view_menu_labels, view_menu_descs):\n            view_menu_item = wx.MenuItem(view_menu, id, label, desc, wx.ITEM_NORMAL)\n            view_menu_items.append(view_menu_item)\n            view_menu.Append(view_menu_item)\n        # Setting up event handlers for the view menu items.\n        # view_menu_events = ['OnZoomIn', 'OnZoomOut', 'OnResetZoom', 'OnTranslate']\n        view_menu_events = ['OnTranslate']\n        for e, item in zip(view_menu_events, view_menu_items):\n            event = getattr(self, e)\n            self.Bind(wx.EVT_MENU, event, item)\n        # Setting up Run menu.\n        run_menu= wx.Menu()\n        menu_bar.Append(run_menu,\"&amp;Run\") # Adding the \"run_menu\" to the MenuBar\n        # create and add menu items to the run menu\n        run_id = wx.ID_ANY\n        # run_jg_id = wx.ID_ANY\n        run_menu_labels = [\"&amp;Run\\tCtrl+R\"]\n        run_menu_item_ids = [run_id]\n        run_menu_descs = [\"Run the selected tool on the given script\"]\n        run_menu_items = []\n        for id, label, desc in itertools.zip_longest(run_menu_item_ids, run_menu_labels, run_menu_descs):\n            run_menu_item = wx.MenuItem(run_menu, id, label, desc, wx.ITEM_NORMAL)\n            run_menu.Append(run_menu_item)  \n            run_menu_items.append(run_menu_item)\n        self.Bind(wx.EVT_MENU, self.OnRun, run_menu_items[0])\n\n\n        # # Setting up Console menu.\n        console_menu= wx.Menu()\n        menu_bar.Append(console_menu,\"&amp;Console\")\n        console_menu_labels = [\"&amp;Clear\\tCtrl+L\", \"&amp;Close Console\\tCtrl+K\"]\n        console_menu_item_ids = [wx.ID_ANY, wx.ID_ANY]\n        console_menu_descs = [\"To clear the console\", \"To close the console\"]\n        console_menu_items = []\n        for id, label, desc in itertools.zip_longest(console_menu_item_ids, console_menu_labels, console_menu_descs):\n            console_menu_item = wx.MenuItem(console_menu, id, label, desc, wx.ITEM_NORMAL)\n            console_menu.Append(console_menu_item)  \n            console_menu_items.append(console_menu_item)\n        # Setting up event handlers for the console menu items.\n        console_menu_events = ['OnClear', 'OnCloseConsole']\n        for e, item in zip(console_menu_events, console_menu_items):\n            event = getattr(self, e)\n            self.Bind(wx.EVT_MENU, event, item)\n        # Setting up Help menu.\n        help_menu= wx.Menu()\n        menu_bar.Append(help_menu,\"&amp;Help\") # Adding the \"help_menu\" to the MenuBar\n\n        help_menu_item1 = wx.MenuItem(help_menu, wx.ID_ABOUT, \"&amp;About\", \"To know about the application\", wx.ITEM_NORMAL)\n        help_menu.Append(help_menu_item1)\n\n         # Set Help menu item events.\n        self.Bind(wx.EVT_MENU, self.OnAbout, help_menu_item1)\n        self.Show(True)\n\n        # Setting up the status bar.\n        self.CreateStatusBar()\n        self.SetStatusText(\"Welcome to AFGI: Augmented Formal Graphical Interface!\")\n\n        # Setting up the tb.\n        tb = self.CreateToolBar( wx.TB_HORIZONTAL | wx.NO_BORDER | wx.TB_FLAT | wx.TB_TEXT )\n        self.SetToolBar(tb)\n\n        dirname = os.path.dirname(__file__)\n        tool_img_dir = os.path.join(dirname, 'bitmaps' )\n\n        tb.AddTool(1, \"New\", wx.Image(tool_img_dir+'/new.png', wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'New', \"Long help for 'New'.\", None)\n        tb.AddTool(2, \"Open\", wx.Image(tool_img_dir+'/open.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Open', \"Long help for 'Open'.\", None)\n        tb.AddTool(3, \"Save\", wx.Image(tool_img_dir+'/save.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Save', \"Long help for 'Save'.\", None)\n        tb.AddSeparator()\n        tb.AddTool(4, \"undo\", wx.Image(tool_img_dir+'/undo.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Undo', \"Long help for 'Undo'.\", None)\n        tb.AddTool(5, \"redo\", wx.Image(tool_img_dir+'/redo.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Redo', \"Long help for 'Redo'.\", None)\n        tb.AddSeparator()\n        tb.AddTool(8, \"Translate\", wx.Image(tool_img_dir+'/convert.png',\n                wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                wx.NullBitmap, wx.ITEM_NORMAL, 'Translate', \"Translate to TCL\", None)\n        self.Bind(wx.EVT_TOOL, self.OnTranslate, id=8)\n        self.tools_combo = wx.ComboBox(tb, choices=[\"VCF\", \"JG\"])\n        tb.AddControl(self.tools_combo)\n        self.apps_combo = wx.ComboBox(tb, choices=[\"FPV\", \"FRV\", \"Etc\"])\n        tb.AddControl(self.apps_combo)\n        self.mode_combo = wx.ComboBox(tb, choices=[\"GUI\", \"Batch\"] )\n        tb.AddControl(self.mode_combo)\n        tb.AddTool(7, \"Run\", wx.Image(tool_img_dir+'/run_button.png',\n                wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                wx.NullBitmap, wx.ITEM_NORMAL, 'Run', \"Long help for 'Run'.\", None)\n        self.Bind(wx.EVT_TOOL, self.OnRun, id=7)\n        tb.AddSeparator()\n        tb.AddTool(6, \"Exit\", wx.Image(tool_img_dir+'/exit.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Exit', \"Long help for 'Exit'.\", None)\n        tb.AddSeparator()\n        tb.Realize()\n        # Redirect the output of the console to the text control\n        self.log = wx.TextCtrl(self.panel2, -1, size=(800, 600), style=wx.TE_MULTILINE|wx.TE_READONLY|wx.HSCROLL)\n        redir = RedirectText(self.log)\n        sys.stdout = redir\n\n        # Set Toolbar events.\n        tool_bar_items = ['OnNew', 'OnOpen', 'OnSave', 'OnUndo', 'OnRedo', 'OnExit']\n        for item, i in zip(tool_bar_items, range(6)):\n            item = getattr(self, item)\n            self.Bind(wx.EVT_TOOL, item, id=i+1)\n\n        # Set Run menu item events.\n        self.Bind(wx.EVT_MENU, self.OnRun, run_menu_items[0])\n\n        # # Set Console menu item events.\n        # self.Bind(wx.EVT_MENU, self.OnNewTerminal, terminal_menu_item1)\n        # self.Bind(wx.EVT_MENU, self.OnCloseTerminal, terminal_menu_item2)\n\n        # Shortcuts for menu items\n        key_shortcuts = [\"N\", \"O\", \"S\", \"P\", \"Q\"]\n        for key, id, item in itertools.zip_longest(key_shortcuts, file_menu_item_ids, file_menu_items):\n          tmp = wx.AcceleratorEntry(wx.ACCEL_CTRL, ord(key), id)\n          item.SetAccel(tmp)\n\n        # Create Tool \n        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.OnPageChanged)\n        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGING, self.OnPageChanging)\n\n    # Run event handlers\n    def OnRun(self, event):\n        \"\"\" A method to run a tool on the given script with the given arguments\"\"\"\n        # Get the selected choice\n        params = [self.apps_combo.GetValue(), self.mode_combo.GetValue()]\n        idx = self.nb.GetSelection()\n        script = self.nb.GetPageText(idx)\n        if script.endswith(\".yaml\"):\n            import afgi.yaml_to_tcl.tcl_gen as TclGen\n            TclGen.TclGen(script, script.replace(\".yaml\", \".tcl\"))\n            script = script.replace(\".yaml\", \".tcl\")\n        tool = self.tools_combo.GetValue().lower()\n        from afgi.run_tools import RunTool\n        run_obj = RunTool(tool, script, params)\n        try:\n            err = run_obj.run()\n        except:\n            pass\n        RedirectText(self.log).write(f\"$ {tool} {script} {' '.join(['-'+x.lower() for x in params])}\\n\")\n\n\n    # On clear console\n    def OnClear(self, event):\n        \"\"\" A method to clear the console\"\"\"\n        self.log.Clear()\n\n    # Translate event handlers\n    def OnTranslate(self, event):\n        \"\"\" A method to translate a yaml file to tcl and open it in a new tab\"\"\"\n        # Get the selected choice\n        idx = self.nb.GetSelection()\n        script = self.nb.GetPageText(idx)\n        tcl_file = script.replace(\".yaml\", \".tcl\")\n        if os.path.isfile(tcl_file):\n            wx.MessageBox(f\"TCL file {tcl_file} already exists!\", \"Please confirm\", \n                      wx.ICON_QUESTION | wx.YES_NO, self) == wx.YES\n            RedirectText(self.log).write(f\"$ Openining the existing {tcl_file}!\\n\")\n        else:\n            import afgi.yaml_to_tcl.tcl_gen as TclGen\n            TclGen.TclGen(script, tcl_file)\n            RedirectText(self.log).write(f\"$ Generating and opening {tcl_file}!\\n\")\n        f = open(tcl_file, 'r')\n        content = f.read()\n        self.tab = MyPanel(self.nb, content)\n        self.nb.AddPage(self.tab, tcl_file, True)\n        f.close()\n\n\n    def OnPageChanged(self, event):\n          \"\"\" A method to handle the page changed event\"\"\"\n          old = event.GetOldSelection()\n          new = event.GetSelection()\n          sel = self.nb.GetSelection()\n        #   print ('OnPageChanged,  old:%d, new:%d, sel:%d\\n' % (old, new, sel))\n          event.Skip()\n\n    def OnPageChanging(self, event):\n          \"\"\" A method to handle the page changing event\"\"\"\n          old = event.GetOldSelection()\n          new = event.GetSelection()\n          sel = self.nb.GetSelection()\n        #   print ('OnPageChanging, old:%d, new:%d, sel:%d\\n' % (old, new, sel))\n          event.Skip()\n    # File menu item event handlers\n    def MyFileDialog(self, text, style, mode):\n        \"\"\" A method to create a file dialog box\n        Args:\n            text (str): text to be displayed in the status bar\n            style (int): style of the file dialog box\n            mode (str): set the file mode: read, write, append, etc.\n        \"\"\"\n        dlg = wx.FileDialog(self, \"Give a file name\", self.dirname, self.filename, wildcard, style)\n        if dlg.ShowModal() == wx.ID_OK:\n            self.filename = dlg.GetFilename()\n            self.dirname = dlg.GetDirectory()\n            if mode == \"new\":\n                f = open(os.path.join(self.dirname, self.filename), 'w')\n                self.tab = MyPanel(self.nb, \"\")\n                self.nb.AddPage(self.tab, self.filename, True)\n                self.PushStatusText(text)\n                f.close()\n            elif mode == \"open\":\n                f = open(os.path.join(self.dirname, self.filename), 'r')\n                content = f.read()\n                self.tab = MyPanel(self.nb, content)\n                self.nb.AddPage(self.tab, self.filename, True)\n                f.close()\n                self.PushStatusText(text)\n            elif mode == \"write\":\n                f = open(os.path.join(self.dirname, self.filename), 'w')\n                f.write(self.nb.GetCurrentPage().text.GetValue())\n                self.tab = MyPanel(self.nb, self.nb.GetCurrentPage().text.GetValue())\n                self.nb.AddPage(self.tab, self.filename, True)\n                f.close()\n                self.PushStatusText(text)\n            else:\n                pass\n        dlg.Destroy()\n\n    def SaveCurrentFile(self):\n        \"\"\" A method to display a message box to save the current file\"\"\"\n        return wx.MessageBox(\"Do you want to save the file?\", \"Please confirm\", \n                      wx.ICON_QUESTION | wx.YES_NO, self) == wx.YES\n\n    def OnNew(self, event):\n        \"\"\" A method to create a new file\"\"\"\n        if self.nb.GetCurrentPage() is not None:\n            if self.nb.GetCurrentPage().text.IsModified():\n                if self.SaveCurrentFile():\n                    self.OnSave(event)\n        self.MyFileDialog(\"New file Created!\", wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT, \"new\")\n\n    def OnOpen(self, event):\n        \"\"\" A method to open a file\"\"\"\n        if self.nb.GetCurrentPage() is not None: \n            if self.nb.GetCurrentPage().text.IsModified():\n                if self.SaveCurrentFile():\n                    self.OnSave(event)\n        self.MyFileDialog(\"File opened!\", wx.FD_OPEN | wx.FD_FILE_MUST_EXIST, \"open\")\n\n    def OnSave(self, event):\n        \"\"\" A method to handle the save event\"\"\"\n        if self.nb.GetCurrentPage() is not None:\n            if self.nb.GetCurrentPage().text.IsModified():\n                index = self.nb.GetSelection()\n                f = open(os.path.join(os.getcwd(), self.nb.GetPageText(index)), 'w')\n                f.write(self.nb.GetCurrentPage().text.GetValue())\n                self.nb_changed = False\n                self.PushStatusText(\"File saved!\")\n                f.close()\n\n    def OnSaveAs(self, event):\n        \"\"\" A method to handle the \"save as\" event\"\"\"\n        self.MyFileDialog(\"File saved!\", wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT, \"write\")\n\n    def OnExit(self, event):\n        \"\"\" A method to handle the exit event\"\"\"\n        self.Close(True)  # Close the frame.\n\n    # edit menu item event handlers        \n    def OnUndo(self, event):\n        \"\"\" A method to handle the undo event\"\"\"\n        self.nb.GetCurrentPage().text.Undo()\n\n    def OnRedo(self, event):\n        \"\"\" A method to handle the redo event\"\"\"\n        self.nb.GetCurrentPage().text.Redo()\n\n    def OnCut(self, event):\n        \"\"\" A method to handle the cut event\"\"\"\n        self.nb.GetCurrentPage().text.Cut()\n\n    def OnCopy(self, event):\n        \"\"\" A method to handle the copy event\"\"\"\n        self.nb.GetCurrentPage().text.Copy()\n\n    def OnPaste(self, event):\n        \"\"\" A method to handle the paste event\"\"\"\n        self.nb.GetCurrentPage().text.Paste()\n\n    def OnDelete(self, event):\n        \"\"\" A method to handle the delete event\"\"\"\n        self.nb.GetCurrentPage().text.Clear()\n\n    def OnSelectAll(self, event):\n        \"\"\" A method to handle the select all event\"\"\"\n        self.nb.GetCurrentPage().text.SelectAll()\n\n    # Console menu item event handlers\n    def OnClearConsole(self, event):\n        \"\"\" A method to clear the console\"\"\"\n        self.log.Clear()\n    def OnCloseConsole(self, event):\n        \"\"\" A method to close the console\"\"\"\n        self.panel2.Destroy()\n\n    # Help menu item event handlers\n    def OnAbout(self, event):\n        \"\"\" A method to display the about dialog box\"\"\"\n        dlg = wx.MessageDialog( self, \"AFGI: Augmented Formal Graphical Interface\\nVersion 0.0.1\", \"About AFGI\", wx.OK)\n        dlg.ShowModal() # Show it\n        dlg.Destroy() # finally destroy it when finished.\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.MyFileDialog","title":"<code>MyFileDialog(text, style, mode)</code>","text":"<p>A method to create a file dialog box Args:     text (str): text to be displayed in the status bar     style (int): style of the file dialog box     mode (str): set the file mode: read, write, append, etc.</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def MyFileDialog(self, text, style, mode):\n    \"\"\" A method to create a file dialog box\n    Args:\n        text (str): text to be displayed in the status bar\n        style (int): style of the file dialog box\n        mode (str): set the file mode: read, write, append, etc.\n    \"\"\"\n    dlg = wx.FileDialog(self, \"Give a file name\", self.dirname, self.filename, wildcard, style)\n    if dlg.ShowModal() == wx.ID_OK:\n        self.filename = dlg.GetFilename()\n        self.dirname = dlg.GetDirectory()\n        if mode == \"new\":\n            f = open(os.path.join(self.dirname, self.filename), 'w')\n            self.tab = MyPanel(self.nb, \"\")\n            self.nb.AddPage(self.tab, self.filename, True)\n            self.PushStatusText(text)\n            f.close()\n        elif mode == \"open\":\n            f = open(os.path.join(self.dirname, self.filename), 'r')\n            content = f.read()\n            self.tab = MyPanel(self.nb, content)\n            self.nb.AddPage(self.tab, self.filename, True)\n            f.close()\n            self.PushStatusText(text)\n        elif mode == \"write\":\n            f = open(os.path.join(self.dirname, self.filename), 'w')\n            f.write(self.nb.GetCurrentPage().text.GetValue())\n            self.tab = MyPanel(self.nb, self.nb.GetCurrentPage().text.GetValue())\n            self.nb.AddPage(self.tab, self.filename, True)\n            f.close()\n            self.PushStatusText(text)\n        else:\n            pass\n    dlg.Destroy()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnAbout","title":"<code>OnAbout(event)</code>","text":"<p>A method to display the about dialog box</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnAbout(self, event):\n    \"\"\" A method to display the about dialog box\"\"\"\n    dlg = wx.MessageDialog( self, \"AFGI: Augmented Formal Graphical Interface\\nVersion 0.0.1\", \"About AFGI\", wx.OK)\n    dlg.ShowModal() # Show it\n    dlg.Destroy() # finally destroy it when finished.\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnClear","title":"<code>OnClear(event)</code>","text":"<p>A method to clear the console</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnClear(self, event):\n    \"\"\" A method to clear the console\"\"\"\n    self.log.Clear()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnClearConsole","title":"<code>OnClearConsole(event)</code>","text":"<p>A method to clear the console</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnClearConsole(self, event):\n    \"\"\" A method to clear the console\"\"\"\n    self.log.Clear()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnCloseConsole","title":"<code>OnCloseConsole(event)</code>","text":"<p>A method to close the console</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnCloseConsole(self, event):\n    \"\"\" A method to close the console\"\"\"\n    self.panel2.Destroy()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnCopy","title":"<code>OnCopy(event)</code>","text":"<p>A method to handle the copy event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnCopy(self, event):\n    \"\"\" A method to handle the copy event\"\"\"\n    self.nb.GetCurrentPage().text.Copy()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnCut","title":"<code>OnCut(event)</code>","text":"<p>A method to handle the cut event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnCut(self, event):\n    \"\"\" A method to handle the cut event\"\"\"\n    self.nb.GetCurrentPage().text.Cut()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnDelete","title":"<code>OnDelete(event)</code>","text":"<p>A method to handle the delete event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnDelete(self, event):\n    \"\"\" A method to handle the delete event\"\"\"\n    self.nb.GetCurrentPage().text.Clear()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnExit","title":"<code>OnExit(event)</code>","text":"<p>A method to handle the exit event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnExit(self, event):\n    \"\"\" A method to handle the exit event\"\"\"\n    self.Close(True)  # Close the frame.\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnNew","title":"<code>OnNew(event)</code>","text":"<p>A method to create a new file</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnNew(self, event):\n    \"\"\" A method to create a new file\"\"\"\n    if self.nb.GetCurrentPage() is not None:\n        if self.nb.GetCurrentPage().text.IsModified():\n            if self.SaveCurrentFile():\n                self.OnSave(event)\n    self.MyFileDialog(\"New file Created!\", wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT, \"new\")\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnOpen","title":"<code>OnOpen(event)</code>","text":"<p>A method to open a file</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnOpen(self, event):\n    \"\"\" A method to open a file\"\"\"\n    if self.nb.GetCurrentPage() is not None: \n        if self.nb.GetCurrentPage().text.IsModified():\n            if self.SaveCurrentFile():\n                self.OnSave(event)\n    self.MyFileDialog(\"File opened!\", wx.FD_OPEN | wx.FD_FILE_MUST_EXIST, \"open\")\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnPageChanged","title":"<code>OnPageChanged(event)</code>","text":"<p>A method to handle the page changed event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnPageChanged(self, event):\n      \"\"\" A method to handle the page changed event\"\"\"\n      old = event.GetOldSelection()\n      new = event.GetSelection()\n      sel = self.nb.GetSelection()\n    #   print ('OnPageChanged,  old:%d, new:%d, sel:%d\\n' % (old, new, sel))\n      event.Skip()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnPageChanging","title":"<code>OnPageChanging(event)</code>","text":"<p>A method to handle the page changing event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnPageChanging(self, event):\n      \"\"\" A method to handle the page changing event\"\"\"\n      old = event.GetOldSelection()\n      new = event.GetSelection()\n      sel = self.nb.GetSelection()\n    #   print ('OnPageChanging, old:%d, new:%d, sel:%d\\n' % (old, new, sel))\n      event.Skip()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnPaste","title":"<code>OnPaste(event)</code>","text":"<p>A method to handle the paste event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnPaste(self, event):\n    \"\"\" A method to handle the paste event\"\"\"\n    self.nb.GetCurrentPage().text.Paste()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnRedo","title":"<code>OnRedo(event)</code>","text":"<p>A method to handle the redo event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnRedo(self, event):\n    \"\"\" A method to handle the redo event\"\"\"\n    self.nb.GetCurrentPage().text.Redo()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnRun","title":"<code>OnRun(event)</code>","text":"<p>A method to run a tool on the given script with the given arguments</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnRun(self, event):\n    \"\"\" A method to run a tool on the given script with the given arguments\"\"\"\n    # Get the selected choice\n    params = [self.apps_combo.GetValue(), self.mode_combo.GetValue()]\n    idx = self.nb.GetSelection()\n    script = self.nb.GetPageText(idx)\n    if script.endswith(\".yaml\"):\n        import afgi.yaml_to_tcl.tcl_gen as TclGen\n        TclGen.TclGen(script, script.replace(\".yaml\", \".tcl\"))\n        script = script.replace(\".yaml\", \".tcl\")\n    tool = self.tools_combo.GetValue().lower()\n    from afgi.run_tools import RunTool\n    run_obj = RunTool(tool, script, params)\n    try:\n        err = run_obj.run()\n    except:\n        pass\n    RedirectText(self.log).write(f\"$ {tool} {script} {' '.join(['-'+x.lower() for x in params])}\\n\")\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnSave","title":"<code>OnSave(event)</code>","text":"<p>A method to handle the save event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnSave(self, event):\n    \"\"\" A method to handle the save event\"\"\"\n    if self.nb.GetCurrentPage() is not None:\n        if self.nb.GetCurrentPage().text.IsModified():\n            index = self.nb.GetSelection()\n            f = open(os.path.join(os.getcwd(), self.nb.GetPageText(index)), 'w')\n            f.write(self.nb.GetCurrentPage().text.GetValue())\n            self.nb_changed = False\n            self.PushStatusText(\"File saved!\")\n            f.close()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnSaveAs","title":"<code>OnSaveAs(event)</code>","text":"<p>A method to handle the \"save as\" event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnSaveAs(self, event):\n    \"\"\" A method to handle the \"save as\" event\"\"\"\n    self.MyFileDialog(\"File saved!\", wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT, \"write\")\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnSelectAll","title":"<code>OnSelectAll(event)</code>","text":"<p>A method to handle the select all event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnSelectAll(self, event):\n    \"\"\" A method to handle the select all event\"\"\"\n    self.nb.GetCurrentPage().text.SelectAll()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnTranslate","title":"<code>OnTranslate(event)</code>","text":"<p>A method to translate a yaml file to tcl and open it in a new tab</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnTranslate(self, event):\n    \"\"\" A method to translate a yaml file to tcl and open it in a new tab\"\"\"\n    # Get the selected choice\n    idx = self.nb.GetSelection()\n    script = self.nb.GetPageText(idx)\n    tcl_file = script.replace(\".yaml\", \".tcl\")\n    if os.path.isfile(tcl_file):\n        wx.MessageBox(f\"TCL file {tcl_file} already exists!\", \"Please confirm\", \n                  wx.ICON_QUESTION | wx.YES_NO, self) == wx.YES\n        RedirectText(self.log).write(f\"$ Openining the existing {tcl_file}!\\n\")\n    else:\n        import afgi.yaml_to_tcl.tcl_gen as TclGen\n        TclGen.TclGen(script, tcl_file)\n        RedirectText(self.log).write(f\"$ Generating and opening {tcl_file}!\\n\")\n    f = open(tcl_file, 'r')\n    content = f.read()\n    self.tab = MyPanel(self.nb, content)\n    self.nb.AddPage(self.tab, tcl_file, True)\n    f.close()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.OnUndo","title":"<code>OnUndo(event)</code>","text":"<p>A method to handle the undo event</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def OnUndo(self, event):\n    \"\"\" A method to handle the undo event\"\"\"\n    self.nb.GetCurrentPage().text.Undo()\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyFrame.SaveCurrentFile","title":"<code>SaveCurrentFile()</code>","text":"<p>A method to display a message box to save the current file</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def SaveCurrentFile(self):\n    \"\"\" A method to display a message box to save the current file\"\"\"\n    return wx.MessageBox(\"Do you want to save the file?\", \"Please confirm\", \n                  wx.ICON_QUESTION | wx.YES_NO, self) == wx.YES\n</code></pre>"},{"location":"reference/#afgi.gui.frame.MyPanel","title":"<code>MyPanel</code>","text":"<p>             Bases: <code>Panel</code></p> <p>A class to create a panel for each tab in the notebook</p> <p>Attributes:</p> Name Type Description <code>parent</code> <code>Panel</code> <p>parent panel</p> <code>content</code> <code>str</code> <p>content of the panel</p> <code>text</code> <code>TextCtrl</code> <p>text control to display the content of the panel</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>class MyPanel(wx.Panel): \n    \"\"\"A class to create a panel for each tab in the notebook\n\n    Attributes:\n        parent (wx.Panel): parent panel\n        content (str): content of the panel\n        text (wx.TextCtrl): text control to display the content of the panel\n    \"\"\"\n    def __init__(self, parent, content): \n      super(MyPanel, self).__init__(parent) \n      self.text = wx.TextCtrl(self, style = wx.TE_MULTILINE, value = content, size = wx.Size(800,600)) \n</code></pre>"},{"location":"reference/#afgi.gui.frame.RedirectText","title":"<code>RedirectText</code>","text":"<p>             Bases: <code>object</code></p> <p>A class to redirect the output of the console to the text control</p> <p>Attributes:</p> Name Type Description <code>awxTextCtrl</code> <code>TextCtrl</code> <p>text control to which the output is redirected</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>class RedirectText(object):\n    \"\"\"A class to redirect the output of the console to the text control\n\n    Attributes: \n        awxTextCtrl (wx.TextCtrl): text control to which the output is redirected  \n    \"\"\"\n    def __init__(self, aWxTextCtrl):\n        \"\"\"The constructor of the RedirectText class\"\"\"\n        self.out = aWxTextCtrl\n\n    def write(self, string):\n        \"\"\"A method to write the output to the text control \n        Args:\n            string (str): output string\n        \"\"\"\n        self.out.WriteText(string)\n</code></pre>"},{"location":"reference/#afgi.gui.frame.RedirectText.__init__","title":"<code>__init__(aWxTextCtrl)</code>","text":"<p>The constructor of the RedirectText class</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def __init__(self, aWxTextCtrl):\n    \"\"\"The constructor of the RedirectText class\"\"\"\n    self.out = aWxTextCtrl\n</code></pre>"},{"location":"reference/#afgi.gui.frame.RedirectText.write","title":"<code>write(string)</code>","text":"<p>A method to write the output to the text control  Args:     string (str): output string</p> Source code in <code>src/afgi/gui/frame.py</code> <pre><code>def write(self, string):\n    \"\"\"A method to write the output to the text control \n    Args:\n        string (str): output string\n    \"\"\"\n    self.out.WriteText(string)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrorException","title":"<code>YamlToTclErrorException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A class to define the custom exception for the yaml-to-tcl package.  This class inherits from the Exception class.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>The error message.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>class YamlToTclErrorException(Exception):\n    \"\"\"A class to define the custom exception for the yaml-to-tcl package. \n    This class inherits from the Exception class.\n\n    Attributes:\n        message (str): The error message.\n    \"\"\"\n    def __init__(self, message):\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors","title":"<code>YamlToTclErrors</code>","text":"<p>A class to define the custom errors for the yaml-to-tcl package.</p> <p>Methods:</p> Name Description <code>empty_yaml_error</code> <p>A method to define the error message for empty yaml file.</p> <code>invalid_yaml_error</code> <p>A method to define the error message for invalid yaml file.</p> <code>tool_error</code> <p>A method to define the error message for invalid tool name.</p> <code>tool_name_error</code> <p>A method to define the error message for invalid tool name.</p> <code>appmode_error</code> <p>A method to define the error message for invalid appmode name.</p> <code>read_file_error</code> <p>A method to define the error message for invalid read_file name.</p> <code>read_file_top_error</code> <p>A method to define the error message for invalid top module name.</p> <code>read_file_format_error</code> <p>A method to define the error message for invalid RTL format.</p> <code>read_file_filelist_error</code> <p>A method to define the error message for invalid RTL filelist.</p> <code>clock_error</code> <p>A method to define the error message for invalid clock name.</p> <code>clock_name_error</code> <p>A method to define the error message for invalid clock name.</p> <code>clock_period_error</code> <p>A method to define the error message for invalid clock period.</p> <code>reset_error</code> <p>A method to define the error message for invalid reset name.</p> <code>reset_name_error</code> <p>A method to define the error message for invalid reset name.</p> <code>reset_sense_error</code> <p>A method to define the error message for invalid reset sense.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>class YamlToTclErrors:\n   \"\"\"A class to define the custom errors for the yaml-to-tcl package.\n\n    Methods:\n        empty_yaml_error: A method to define the error message for empty yaml file.\n        invalid_yaml_error: A method to define the error message for invalid yaml file.\n        tool_error: A method to define the error message for invalid tool name.\n        tool_name_error: A method to define the error message for invalid tool name.\n        appmode_error: A method to define the error message for invalid appmode name.\n        read_file_error: A method to define the error message for invalid read_file name.\n        read_file_top_error: A method to define the error message for invalid top module name.\n        read_file_format_error: A method to define the error message for invalid RTL format.\n        read_file_filelist_error: A method to define the error message for invalid RTL filelist.\n        clock_error: A method to define the error message for invalid clock name.\n        clock_name_error: A method to define the error message for invalid clock name.\n        clock_period_error: A method to define the error message for invalid clock period.\n        reset_error: A method to define the error message for invalid reset name.\n        reset_name_error: A method to define the error message for invalid reset name.\n        reset_sense_error: A method to define the error message for invalid reset sense.\n    \"\"\"\n   def __init__(self):\n       \"\"\"Constructor for the YamlToTclErrors class.\"\"\"\n       pass\n   def empty_yaml_error (self):\n        \"\"\" A method to define the error message for empty yaml file.\"\"\"\n        return \"Empty Yaml file passed!!\"\n\n   def invalid_yaml_error (self):\n        \"\"\" A method to define the error message for invalid yaml file.\"\"\"\n        return \"Invalid YAML file passed!!\"\n\n   def tool_error (self):\n        \"\"\" A method to define the error message for invalid tool name.\"\"\"\n        return \"Tool value None!\"\n\n   def tool_name_error (self):\n        \"\"\" A method to define the error message for invalid tool name.\"\"\"\n        return \"Unsupported tool name!\"\n\n   def appmode_error(self):\n        \"\"\" A method to define the error message for invalid appmode name.\"\"\"\n        return \"Tool appmode value None!\"\n\n   def read_file_error(self):\n        \"\"\" A method to define the error message for invalid read_file name.\"\"\"\n        return \"read_file value None!\"\n\n   def read_file_top_error (self):\n        \"\"\" A method to define the error message for invalid top module name.\"\"\"\n        return \"RTL top module value None!\"\n\n   def read_file_format_error (self):\n        \"\"\" A method to define the error message for invalid RTL format.\"\"\"\n        return \"RTL format value None!\"\n\n   def read_file_filelist_error (self):\n        \"\"\" A method to define the error message for invalid RTL filelist.\"\"\"\n        return \"RTL filelist value None!\"\n\n   def clock_error (self):\n        \"\"\" A method to define the error message for invalid clock name.\"\"\"\n        return \"Clock value None!\"\n\n   def clock_name_error (self):\n        \"\"\" A method to define the error message for invalid clock name.\"\"\"\n        return \"Clock name value None!\"\n\n   def clock_period_error (self):\n        \"\"\" A method to define the error message for invalid clock period.\"\"\"\n        return \"Clock period value None!\"\n\n   def reset_error (self):\n        \"\"\" A method to define the error message for invalid reset name.\"\"\"\n        return \"Reset value None!\"\n\n   def reset_name_error (self):\n        \"\"\" A method to define the error message for invalid reset name.\"\"\"\n        return \"Reset name value None!\"\n\n   def reset_sense_error (self):\n        \"\"\" A method to define the error message for invalid reset sense.\"\"\"\n        return \"Reset sense value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the YamlToTclErrors class.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructor for the YamlToTclErrors class.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.appmode_error","title":"<code>appmode_error()</code>","text":"<p>A method to define the error message for invalid appmode name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def appmode_error(self):\n     \"\"\" A method to define the error message for invalid appmode name.\"\"\"\n     return \"Tool appmode value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.clock_error","title":"<code>clock_error()</code>","text":"<p>A method to define the error message for invalid clock name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def clock_error (self):\n     \"\"\" A method to define the error message for invalid clock name.\"\"\"\n     return \"Clock value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.clock_name_error","title":"<code>clock_name_error()</code>","text":"<p>A method to define the error message for invalid clock name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def clock_name_error (self):\n     \"\"\" A method to define the error message for invalid clock name.\"\"\"\n     return \"Clock name value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.clock_period_error","title":"<code>clock_period_error()</code>","text":"<p>A method to define the error message for invalid clock period.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def clock_period_error (self):\n     \"\"\" A method to define the error message for invalid clock period.\"\"\"\n     return \"Clock period value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.empty_yaml_error","title":"<code>empty_yaml_error()</code>","text":"<p>A method to define the error message for empty yaml file.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def empty_yaml_error (self):\n     \"\"\" A method to define the error message for empty yaml file.\"\"\"\n     return \"Empty Yaml file passed!!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.invalid_yaml_error","title":"<code>invalid_yaml_error()</code>","text":"<p>A method to define the error message for invalid yaml file.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def invalid_yaml_error (self):\n     \"\"\" A method to define the error message for invalid yaml file.\"\"\"\n     return \"Invalid YAML file passed!!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.read_file_error","title":"<code>read_file_error()</code>","text":"<p>A method to define the error message for invalid read_file name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def read_file_error(self):\n     \"\"\" A method to define the error message for invalid read_file name.\"\"\"\n     return \"read_file value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.read_file_filelist_error","title":"<code>read_file_filelist_error()</code>","text":"<p>A method to define the error message for invalid RTL filelist.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def read_file_filelist_error (self):\n     \"\"\" A method to define the error message for invalid RTL filelist.\"\"\"\n     return \"RTL filelist value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.read_file_format_error","title":"<code>read_file_format_error()</code>","text":"<p>A method to define the error message for invalid RTL format.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def read_file_format_error (self):\n     \"\"\" A method to define the error message for invalid RTL format.\"\"\"\n     return \"RTL format value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.read_file_top_error","title":"<code>read_file_top_error()</code>","text":"<p>A method to define the error message for invalid top module name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def read_file_top_error (self):\n     \"\"\" A method to define the error message for invalid top module name.\"\"\"\n     return \"RTL top module value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.reset_error","title":"<code>reset_error()</code>","text":"<p>A method to define the error message for invalid reset name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def reset_error (self):\n     \"\"\" A method to define the error message for invalid reset name.\"\"\"\n     return \"Reset value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.reset_name_error","title":"<code>reset_name_error()</code>","text":"<p>A method to define the error message for invalid reset name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def reset_name_error (self):\n     \"\"\" A method to define the error message for invalid reset name.\"\"\"\n     return \"Reset name value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.reset_sense_error","title":"<code>reset_sense_error()</code>","text":"<p>A method to define the error message for invalid reset sense.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def reset_sense_error (self):\n     \"\"\" A method to define the error message for invalid reset sense.\"\"\"\n     return \"Reset sense value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.tool_error","title":"<code>tool_error()</code>","text":"<p>A method to define the error message for invalid tool name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def tool_error (self):\n     \"\"\" A method to define the error message for invalid tool name.\"\"\"\n     return \"Tool value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.tool_name_error","title":"<code>tool_name_error()</code>","text":"<p>A method to define the error message for invalid tool name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def tool_name_error (self):\n     \"\"\" A method to define the error message for invalid tool name.\"\"\"\n     return \"Unsupported tool name!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen.TclGen","title":"<code>TclGen</code>","text":"<p>This class is used to generate TCL files from YAML files.</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen.py</code> <pre><code>class TclGen():\n    \"\"\" This class is used to generate TCL files from YAML files. \"\"\"\n    def __init__(self, in_file, out_file):\n        \"\"\" The constructor for TclGen class.\n        \"\"\"\n        self.in_file = in_file\n        self.out_file = out_file\n        self.dic = self.load_yaml_file(self.in_file)\n        print('The tool is: ', self.dic['tool'])\n        if self.dic['tool'] == \"VC-Formal\":\n                TclGenVcf(self.dic, self.out_file)\n        elif self.dic['tool'] == \"JasperGold\":\n                TclGenJg(self.dic, self.out_file)\n        else:\n            self.yaml_exception = YamlToTclErrors()\n            raise YamlToTclErrorException(self.yaml_exception.tool_error())\n\n    def load_yaml_file(self, input_file):\n            \"\"\" This method is used to load the YAML file into a python object.\n            \"\"\"\n            # Check if file exists\n            if not os.path.isfile(input_file):\n                raise FileNotFoundError(f'File {input_file} not found.')\n            # Check if file is empty\n            if os.stat(input_file).st_size == 0:\n                raise YamlToTclErrorException(self.yaml_exception.empty_yaml_error())\n            # Check if file is a valid YAML file\n            try:\n                with open(input_file, 'r') as stream:\n                    dic = yaml.safe_load(stream)\n                return dic\n            except yaml.YAMLError as exc:\n                print(exc)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen.TclGen.__init__","title":"<code>__init__(in_file, out_file)</code>","text":"<p>The constructor for TclGen class.</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen.py</code> <pre><code>def __init__(self, in_file, out_file):\n    \"\"\" The constructor for TclGen class.\n    \"\"\"\n    self.in_file = in_file\n    self.out_file = out_file\n    self.dic = self.load_yaml_file(self.in_file)\n    print('The tool is: ', self.dic['tool'])\n    if self.dic['tool'] == \"VC-Formal\":\n            TclGenVcf(self.dic, self.out_file)\n    elif self.dic['tool'] == \"JasperGold\":\n            TclGenJg(self.dic, self.out_file)\n    else:\n        self.yaml_exception = YamlToTclErrors()\n        raise YamlToTclErrorException(self.yaml_exception.tool_error())\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen.TclGen.load_yaml_file","title":"<code>load_yaml_file(input_file)</code>","text":"<p>This method is used to load the YAML file into a python object.</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen.py</code> <pre><code>def load_yaml_file(self, input_file):\n        \"\"\" This method is used to load the YAML file into a python object.\n        \"\"\"\n        # Check if file exists\n        if not os.path.isfile(input_file):\n            raise FileNotFoundError(f'File {input_file} not found.')\n        # Check if file is empty\n        if os.stat(input_file).st_size == 0:\n            raise YamlToTclErrorException(self.yaml_exception.empty_yaml_error())\n        # Check if file is a valid YAML file\n        try:\n            with open(input_file, 'r') as stream:\n                dic = yaml.safe_load(stream)\n            return dic\n        except yaml.YAMLError as exc:\n            print(exc)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen_vcf.TclGenVcf","title":"<code>TclGenVcf</code>","text":"<p>This class is used to generate a TCL file for VCF.</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen_vcf.py</code> <pre><code>class TclGenVcf():\n        \"\"\"This class is used to generate a TCL file for VCF.\n        \"\"\" \n        def __init__(self, dic, out_file):  \n            \"\"\"Constructor for the class.\n            Args:\n                dic (dict): Dictionary containing the YAML file data.\n                out_file (str): Name of the output file.\n            \"\"\"\n            self.dic = dic\n            self.out_file = out_file\n            self.yaml_exception = YamlToTclErrors()\n        # output file name\n            file = open(self.out_file, 'w+') \n            self.out_file = file\n            self.prelude()\n        # check if appmode is non empty\n            app_mode = self.dic['appmode']\n            if app_mode == None:\n                raise YamlToTclErrorException(self.yaml_exception.appmode_error())\n            set_app_mode = \"set_app_mode \"+ app_mode +\"\\n\\n\"\n            self.out_file.writelines(set_app_mode)\n            if app_mode == \"FPV\":\n                fpv = FPV(self.dic, self.out_file)\n                fpv.set_vars()\n                fpv.blackbox()\n                fpv.read_file()\n                fpv.clock()\n                fpv.reset()\n            elif app_mode == \"AEP\":\n                aep = AEP(self.dic, self.out_file)\n                aep.set_vars()\n                aep.blackbox()\n                aep.read_file()\n                aep.clock()\n                aep.reset()\n            elif app_mode == \"FRV\":\n                frv = FRV(self.dic, self.out_file)\n                frv.set_vars()\n                frv.blackbox()\n                frv.frv_load()\n                frv.read_file()\n                frv.clock()\n                frv.reset()\n            elif app_mode == \"FCA\":\n                fca = FCA(self.dic, self.out_file)\n                fca.set_vars()\n                simdb = self.dic['cov']['cov_input']\n                cov_dut = self.dic['cov']['cov_dut']\n                fca.read_sim_db(simdb, cov_dut)\n                fca.blackbox()\n                fca.read_file()\n                cert_db = self.dic['certitude-DB']\n                fca.read_cert_fault_db(cert_db)\n                fca.clock()\n                fca.reset()\n            else:\n                 raise YamlToTclErrorException(self.yaml_exception.appmode_error())\n            self.check_fv()\n            self.out_file.close()\n            print('The TCL file {} generated!!'.format(self.out_file.name))\n\n        def prelude(self):\n            \"\"\"This method writes the prelude to the TCL file. This includes the shebang, date and task.\n            \"\"\"\n            shebang = \"#! /usr/bin/tclsh \\n\"\n            now = \"# Generated for VCF on \"+str(datetime.datetime.now())+\"\\n\"\n            task = self.dic['task']\n            prelude = shebang + now + \"# \" + task + \"\\n\\n\"\n            self.out_file.writelines(prelude)\n\n        def check_fv(self):\n            \"\"\"This method writes the check_fv command to the TCL file.\n            \"\"\"\n            check_mode = self.dic['check-mode']\n            check_fv = \"check_fv \" + check_mode + \"\\n\\n\"\n            self.out_file.writelines(check_fv)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen_vcf.TclGenVcf.__init__","title":"<code>__init__(dic, out_file)</code>","text":"<p>Constructor for the class. Args:     dic (dict): Dictionary containing the YAML file data.     out_file (str): Name of the output file.</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen_vcf.py</code> <pre><code>def __init__(self, dic, out_file):  \n    \"\"\"Constructor for the class.\n    Args:\n        dic (dict): Dictionary containing the YAML file data.\n        out_file (str): Name of the output file.\n    \"\"\"\n    self.dic = dic\n    self.out_file = out_file\n    self.yaml_exception = YamlToTclErrors()\n# output file name\n    file = open(self.out_file, 'w+') \n    self.out_file = file\n    self.prelude()\n# check if appmode is non empty\n    app_mode = self.dic['appmode']\n    if app_mode == None:\n        raise YamlToTclErrorException(self.yaml_exception.appmode_error())\n    set_app_mode = \"set_app_mode \"+ app_mode +\"\\n\\n\"\n    self.out_file.writelines(set_app_mode)\n    if app_mode == \"FPV\":\n        fpv = FPV(self.dic, self.out_file)\n        fpv.set_vars()\n        fpv.blackbox()\n        fpv.read_file()\n        fpv.clock()\n        fpv.reset()\n    elif app_mode == \"AEP\":\n        aep = AEP(self.dic, self.out_file)\n        aep.set_vars()\n        aep.blackbox()\n        aep.read_file()\n        aep.clock()\n        aep.reset()\n    elif app_mode == \"FRV\":\n        frv = FRV(self.dic, self.out_file)\n        frv.set_vars()\n        frv.blackbox()\n        frv.frv_load()\n        frv.read_file()\n        frv.clock()\n        frv.reset()\n    elif app_mode == \"FCA\":\n        fca = FCA(self.dic, self.out_file)\n        fca.set_vars()\n        simdb = self.dic['cov']['cov_input']\n        cov_dut = self.dic['cov']['cov_dut']\n        fca.read_sim_db(simdb, cov_dut)\n        fca.blackbox()\n        fca.read_file()\n        cert_db = self.dic['certitude-DB']\n        fca.read_cert_fault_db(cert_db)\n        fca.clock()\n        fca.reset()\n    else:\n         raise YamlToTclErrorException(self.yaml_exception.appmode_error())\n    self.check_fv()\n    self.out_file.close()\n    print('The TCL file {} generated!!'.format(self.out_file.name))\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen_vcf.TclGenVcf.check_fv","title":"<code>check_fv()</code>","text":"<p>This method writes the check_fv command to the TCL file.</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen_vcf.py</code> <pre><code>def check_fv(self):\n    \"\"\"This method writes the check_fv command to the TCL file.\n    \"\"\"\n    check_mode = self.dic['check-mode']\n    check_fv = \"check_fv \" + check_mode + \"\\n\\n\"\n    self.out_file.writelines(check_fv)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen_vcf.TclGenVcf.prelude","title":"<code>prelude()</code>","text":"<p>This method writes the prelude to the TCL file. This includes the shebang, date and task.</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen_vcf.py</code> <pre><code>def prelude(self):\n    \"\"\"This method writes the prelude to the TCL file. This includes the shebang, date and task.\n    \"\"\"\n    shebang = \"#! /usr/bin/tclsh \\n\"\n    now = \"# Generated for VCF on \"+str(datetime.datetime.now())+\"\\n\"\n    task = self.dic['task']\n    prelude = shebang + now + \"# \" + task + \"\\n\\n\"\n    self.out_file.writelines(prelude)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.utils.Utils","title":"<code>Utils</code>","text":"<p>This class defines some utility functions.</p> Source code in <code>src/afgi/yaml_to_tcl/utils.py</code> <pre><code>class Utils ():\n    \"\"\" This class defines some utility functions.\n    \"\"\"\n    def __init__(self, filelist):\n        \"\"\" The constructor for Utils class.\n        \"\"\"\n        self.filelist = filelist\n\n    def tcl_filelist(self):\n        \"\"\"Convert a list of files to a TCL filelist.\n        Args:\n            filelist (list): A list of files.\n\n        Returns:\n        filelist (str): A file list in TCL format.\n        \"\"\"\n        flist = \"{ \"\n        for file in self.filelist:\n            flist = flist + str(file) + \" \"\n        flist = flist + \"}\"\n        return flist\n    def append_opts(self, opts):\n        \"\"\"Append options to a string.\n        Example:\n           1. opts = [\"a\"]\n              append_opts(opts)\n              \"a\"\n           2. opts = [\"a\", \"b\"]\n              append_opts(opts)\n              \"a+b\"           \n        \"\"\"\n        res = \"\"\n        if opts != None and len(opts) &gt; 1:\n            for idx, opt in enumerate(opts):\n                if idx == 0:\n                    res = res + str(opt)\n                else:\n                    res = res + \"+\" + str(opt)\n            return res\n        elif opts != None and len(opts) == 1:\n            res = res + str(opts[0])\n            return res\n        else:\n            return res\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.utils.Utils.__init__","title":"<code>__init__(filelist)</code>","text":"<p>The constructor for Utils class.</p> Source code in <code>src/afgi/yaml_to_tcl/utils.py</code> <pre><code>def __init__(self, filelist):\n    \"\"\" The constructor for Utils class.\n    \"\"\"\n    self.filelist = filelist\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.utils.Utils.append_opts","title":"<code>append_opts(opts)</code>","text":"<p>Append options to a string. Example:    1. opts = [\"a\"]       append_opts(opts)       \"a\"    2. opts = [\"a\", \"b\"]       append_opts(opts)       \"a+b\"</p> Source code in <code>src/afgi/yaml_to_tcl/utils.py</code> <pre><code>def append_opts(self, opts):\n    \"\"\"Append options to a string.\n    Example:\n       1. opts = [\"a\"]\n          append_opts(opts)\n          \"a\"\n       2. opts = [\"a\", \"b\"]\n          append_opts(opts)\n          \"a+b\"           \n    \"\"\"\n    res = \"\"\n    if opts != None and len(opts) &gt; 1:\n        for idx, opt in enumerate(opts):\n            if idx == 0:\n                res = res + str(opt)\n            else:\n                res = res + \"+\" + str(opt)\n        return res\n    elif opts != None and len(opts) == 1:\n        res = res + str(opts[0])\n        return res\n    else:\n        return res\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.utils.Utils.tcl_filelist","title":"<code>tcl_filelist()</code>","text":"<p>Convert a list of files to a TCL filelist. Args:     filelist (list): A list of files.</p> <p>Returns: filelist (str): A file list in TCL format.</p> Source code in <code>src/afgi/yaml_to_tcl/utils.py</code> <pre><code>def tcl_filelist(self):\n    \"\"\"Convert a list of files to a TCL filelist.\n    Args:\n        filelist (list): A list of files.\n\n    Returns:\n    filelist (str): A file list in TCL format.\n    \"\"\"\n    flist = \"{ \"\n    for file in self.filelist:\n        flist = flist + str(file) + \" \"\n    flist = flist + \"}\"\n    return flist\n</code></pre>"}]}