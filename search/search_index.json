{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This module contains the RunTool class which is used to run any tool  with the given arguments \b class RunTool:     Attributes:         tool (str): tool name         script (str): script name         args (list strings): list of arguments \b     Methods:         get_opts(self): get the options of the tool         run(self): run formal verification tool on the given script</p> <p>This module contains MyFrame class which is used to create the main window of the application class MyFrame:</p> <pre><code>Attributes:\n</code></pre> <p>This module contains the custom errors for the yaml-to-tcl package. </p> <p>Examples:</p> <p>$ python3 errors.py</p> Exports <p>classes: YamlToTclErrorException, YamlToTclErrors</p> <p>Generate TCL file (for VC Formal tool) from YAML configuration.  The YAML file should contain the following fields:</p>"},{"location":"reference/#afgi.run_tools.run.RunTool","title":"<code>RunTool</code>","text":"<p>RunTool class Attributes:     tool (str): tool name     script (str): script name     args (list strings): list of arguments</p> Source code in <code>src/afgi/run_tools/run.py</code> <pre><code>class RunTool:\n    \"\"\" RunTool class\n    Attributes:\n        tool (str): tool name\n        script (str): script name\n        args (list strings): list of arguments\n    \"\"\"\n    def __init__(self, tool, script, args):\n        self.tool = tool\n        self.script = script\n        self.args = args\n\n    def get_opts(self):\n       \"\"\"A method to get the options of the tool\n        Args:\n              None\n        Returns: \n            opts (str): tool options with prefix '-' if not present separated by space  \n       \"\"\"\n       opts = \"\"\n       for arg in self.args:\n            if arg.startswith('-'):\n                opts = opts + ' ' + arg\n            else:\n                opts = opts + ' ' +'-' + arg\n       return opts\n\n    # Run formal verification tool on the given script\n    def run(self):\n        \"\"\" A method to run a tool on the given script with the given arguments\n        Args:\n            None\n        Returns:\n            output (str): output of the tool to the console\n        \"\"\"\n\n        # run tool\n        return os.system(self.tool + ' ' + self.get_opts() + ' ' + self.script)\n</code></pre>"},{"location":"reference/#afgi.run_tools.run.RunTool.get_opts","title":"<code>get_opts()</code>","text":"<p>A method to get the options of the tool Args:       None Returns:      opts (str): tool options with prefix '-' if not present separated by space</p> Source code in <code>src/afgi/run_tools/run.py</code> <pre><code>def get_opts(self):\n   \"\"\"A method to get the options of the tool\n    Args:\n          None\n    Returns: \n        opts (str): tool options with prefix '-' if not present separated by space  \n   \"\"\"\n   opts = \"\"\n   for arg in self.args:\n        if arg.startswith('-'):\n            opts = opts + ' ' + arg\n        else:\n            opts = opts + ' ' +'-' + arg\n   return opts\n</code></pre>"},{"location":"reference/#afgi.run_tools.run.RunTool.run","title":"<code>run()</code>","text":"<p>A method to run a tool on the given script with the given arguments Args:     None Returns:     output (str): output of the tool to the console</p> Source code in <code>src/afgi/run_tools/run.py</code> <pre><code>def run(self):\n    \"\"\" A method to run a tool on the given script with the given arguments\n    Args:\n        None\n    Returns:\n        output (str): output of the tool to the console\n    \"\"\"\n\n    # run tool\n    return os.system(self.tool + ' ' + self.get_opts() + ' ' + self.script)\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.MyFrame","title":"<code>MyFrame</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A class to create the main window of the application</p> <p>Attributes:</p> Name Type Description <code>parent</code> <code>Frame</code> <p>parent frame</p> <code>title</code> <code>str</code> <p>title of the frame</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>class MyFrame(wx.Frame):\n    \"\"\"A class to create the main window of the application\n\n    Attributes:\n        parent (wx.Frame): parent frame\n        title (str): title of the frame \n    \"\"\"\n    def __init__(self, parent, title):\n        wx.Frame.__init__(self, parent, title=title, size=wx.Size(800,600), style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL)\n        self.SetIcon(wx.Icon('./icons/title_bar_icon.ico', wx.BITMAP_TYPE_ANY))\n        # self.SetBackgroundColour(\"gray\")\n        splitter = wx.SplitterWindow(self, -1)\n        self.mainPanel = wx.Panel(splitter, -1, style=wx.DOUBLE_BORDER)\n        self.mainPanel.SetBackgroundColour(\"white\")\n        self.nb = wx.Notebook(self.mainPanel, size=wx.Size(800,600))\n        self.nb_changed = False\n        self.panel2 = wx.Panel(splitter, -1, style=wx.DOUBLE_BORDER)\n        self.panel2.SetBackgroundColour(\"cream\")\n        splitter.SplitVertically(self.mainPanel, self.panel2)\n\n        #-----------------Default names-----------------#\n        self.dirname = '.'\n        self.filename = 'Untitled'\n        #------------------------------------------------#\n\n        # Creating the menubar.\n        menu_bar = wx.MenuBar()\n\n        # Adding the MenuBar to the Frame content.\n        self.SetMenuBar(menu_bar)  \n\n         # Setting up file menu.\n        file_menu= wx.Menu()\n        menu_bar.Append(file_menu, \"&amp;File\") # Adding the \"file_menu\" to the MenuBar\n        # Create and add menu items to the file menu\n        file_menu_labels = [\"&amp;New\\tCtrl+N\", \"&amp;Open\\tCtrl+O\", \"&amp;Save\\tCtrl+S\", \"&amp;Save As\\tAlt+S\", \"&amp;Exit\\tCtrl+Q\"]  \n        file_menu_item_ids = [wx.ID_NEW, wx.ID_OPEN, wx.ID_SAVE, wx.ID_SAVEAS, wx.ID_EXIT]\n        file_menu_descs = [\"Create new file\", \"Open existing file\", \"Save the current file\", \"Save the file with a different name\", \"Exit the application\"]\n        file_menu_items = []\n        for id, label, desc in itertools.zip_longest(file_menu_item_ids, file_menu_labels, file_menu_descs):\n            file_menu_item = wx.MenuItem(file_menu, id, label, desc, wx.ITEM_NORMAL)\n            file_menu_items.append(file_menu_item)\n            file_menu.Append(file_menu_item)           \n        # Setting up event handlers for the file menu items.\n        file_menu_events = ['OnNew', 'OnOpen', 'OnSave', 'OnSaveAs', 'OnExit']\n        for e, item in zip(file_menu_events, file_menu_items):\n            event = getattr(self, e)\n            self.Bind(wx.EVT_MENU, event, item)     \n        # Setting up Edit menu.\n        edit_menu= wx.Menu()\n        menu_bar.Append(edit_menu,\"&amp;Edit\") # Adding the \"edit_menu\" to the MenuBar\n        # create and add menu items to the edit menu\n        edit_menu_labels = [\"&amp;Undo\\tCtrl+Z\", \"&amp;Redo\\tCtrl+Y\", \"&amp;Cut\\tCtrl+X\", \"&amp;Copy\\tCtrl+C\", \"&amp;Paste\\tCtrl+V\", \"&amp;Delete\\tDel\", \"&amp;Select All\\tCtrl+A\"]\n        edit_menu_item_ids = [wx.ID_UNDO, wx.ID_REDO, wx.ID_CUT, wx.ID_COPY, wx.ID_PASTE, wx.ID_DELETE, wx.ID_SELECTALL]\n        edit_menu_descs = [\"To undo the last action\", \"To redo the last action\", \"To cut the selected text\", \"To copy the selected text\", \"To paste the copied text\", \"To delete the selected text\", \"To select all the text\"]\n        edit_menu_items = []\n        for id, label, desc in itertools.zip_longest(edit_menu_item_ids, edit_menu_labels, edit_menu_descs):\n            edit_menu_item = wx.MenuItem(edit_menu, id, label, desc, wx.ITEM_NORMAL)\n            edit_menu_items.append(edit_menu_item)\n            edit_menu.Append(edit_menu_item)\n        # Setting up event handlers for the edit menu items.\n        edit_menu_events = ['OnUndo', 'OnRedo', 'OnCut', 'OnCopy', 'OnPaste', 'OnDelete', 'OnSelectAll']\n        for e, item in zip(edit_menu_events, edit_menu_items):\n            event = getattr(self, e)\n            self.Bind(wx.EVT_MENU, event, item)\n        # Setting up View menu.\n        view_menu= wx.Menu()\n        menu_bar.Append(view_menu,\"&amp;View\") # Adding the \"view_menu\" to the MenuBar\n        # create and add menu items to the view menu\n\n        # Setting up Run menu.\n        run_menu= wx.Menu()\n        menu_bar.Append(run_menu,\"&amp;Run\") # Adding the \"run_menu\" to the MenuBar\n        # create and add menu items to the run menu\n        run_vcf_id = wx.ID_ANY\n        run_jg_id = wx.ID_ANY\n        run_menu_labels = [\"&amp;VCF\", \"&amp;JG\"]\n        run_menu_item_ids = [run_vcf_id, run_jg_id]\n        run_menu_descs = [\"To run VCF\", \"To run JG\"]\n        run_menu_items = []\n        for id, label, desc in itertools.zip_longest(run_menu_item_ids, run_menu_labels, run_menu_descs):\n            run_menu_item = wx.MenuItem(run_menu, id, label, desc, wx.ITEM_NORMAL)\n            run_menu.Append(run_menu_item)  \n            run_menu_items.append(run_menu_item)\n\n        # Setting up Terminal menu.\n        terminal_menu= wx.Menu()\n        menu_bar.Append(terminal_menu, \"&amp;Terminal\")\n\n        terminal_menu_item1 = wx.MenuItem(terminal_menu, wx.ID_ANY, \"&amp;New Terminal\", \"To open a new terminal\", wx.ITEM_NORMAL)\n        terminal_menu.Append(terminal_menu_item1)\n\n        terminal_menu_item2 = wx.MenuItem(terminal_menu, wx.ID_CLOSE, \"&amp;Close Terminal\", \"To close the terminal\", wx.ITEM_NORMAL)\n        terminal_menu.Append(terminal_menu_item2)\n\n        # Setting up Help menu.\n        help_menu= wx.Menu()\n        menu_bar.Append(help_menu,\"&amp;Help\") # Adding the \"help_menu\" to the MenuBar\n\n        help_menu_item1 = wx.MenuItem(help_menu, wx.ID_ABOUT, \"&amp;About\", \"To know about the application\", wx.ITEM_NORMAL)\n        help_menu.Append(help_menu_item1)\n\n         # Set Help menu item events.\n        self.Bind(wx.EVT_MENU, self.OnAbout, help_menu_item1)\n        self.Show(True)\n\n\n        # Setting up the status bar.\n        self.CreateStatusBar()\n        self.SetStatusText(\"Welcome to AFGI: Augmented Formal Graphical Interface!\")\n\n        # Setting up the tb.\n        tb = self.CreateToolBar( wx.TB_HORIZONTAL | wx.NO_BORDER | wx.TB_FLAT | wx.TB_TEXT )\n\n        self.SetToolBar(tb)\n\n\n        tb.AddTool(1, \"New\", wx.Image('/Users/Ajay/afgi/src/afgi/gui/bitmaps/new.png', wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'New', \"Long help for 'New'.\", None)\n        tb.AddTool(2, \"Open\", wx.Image('/Users/Ajay/afgi/src/afgi/gui/bitmaps/open.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Open', \"Long help for 'Open'.\", None)\n        tb.AddTool(3, \"Save\", wx.Image('/Users/Ajay/afgi/src/afgi/gui/bitmaps/save.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Save', \"Long help for 'Save'.\", None)\n        tb.AddSeparator()\n        tb.AddTool(4, \"undo\", wx.Image('/Users/Ajay/afgi/src/afgi/gui/bitmaps/undo.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Undo', \"Long help for 'Undo'.\", None)\n        tb.AddTool(5, \"redo\", wx.Image('/Users/Ajay/afgi/src/afgi/gui/bitmaps/redo.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Redo', \"Long help for 'Redo'.\", None)\n        tb.AddSeparator()\n        combo = wx.ComboBox(tb, choices=[\"FPV\", \"FRV\", \"Etc\"])\n        tb.AddControl(combo)\n        tb.AddSeparator()\n        tb.AddTool(6, \"Exit\", wx.Image('/Users/Ajay/afgi/src/afgi/gui/bitmaps/exit.png',\n                        wx.BITMAP_TYPE_PNG).ConvertToBitmap(),\n                        wx.NullBitmap, wx.ITEM_NORMAL, 'Exit', \"Long help for 'Exit'.\", None)\n        tb.AddSeparator()\n        tb.Realize()\n\n        # Redirect the output of the console to the text control\n        self.log = wx.TextCtrl(self.panel2, -1, size=(800, 600), style=wx.TE_MULTILINE|wx.TE_READONLY|wx.HSCROLL)\n        redir = RedirectText(self.log)\n        sys.stdout = redir\n\n\n        # Set Toolbar events.\n        tool_bar_items = ['OnNew', 'OnOpen', 'OnSave', 'OnUndo', 'OnRedo', 'OnExit']\n        for item, i in zip(tool_bar_items, range(6)):\n            item = getattr(self, item)\n            self.Bind(wx.EVT_TOOL, item, id=i+1)\n\n        # Set View menu item events.\n\n        # Set Run menu item events.\n        self.Bind(wx.EVT_MENU, self.OnVCF, run_menu_items[0])\n        self.Bind(wx.EVT_MENU, self.OnJG, run_menu_items[1])\n\n        # Set Terminal menu item events.\n        self.Bind(wx.EVT_MENU, self.OnNewTerminal, terminal_menu_item1)\n        self.Bind(wx.EVT_MENU, self.OnCloseTerminal, terminal_menu_item2)\n\n        # Shortcuts for menu items\n        key_shortcuts = [\"N\", \"O\", \"S\", \"P\", \"Q\"]\n        for key, id, item in itertools.zip_longest(key_shortcuts, file_menu_item_ids, file_menu_items):\n          tmp = wx.AcceleratorEntry(wx.ACCEL_CTRL, ord(key), id)\n          item.SetAccel(tmp)\n\n        # Create Tool \n        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.OnPageChanged)\n        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGING, self.OnPageChanging)\n\n    def OnPageChanged(self, event):\n          old = event.GetOldSelection()\n          new = event.GetSelection()\n          sel = self.nb.GetSelection()\n          print ('OnPageChanged,  old:%d, new:%d, sel:%d\\n' % (old, new, sel))\n          event.Skip()\n    def OnPageChanging(self, event):\n          old = event.GetOldSelection()\n          new = event.GetSelection()\n          sel = self.nb.GetSelection()\n          print ('OnPageChanging, old:%d, new:%d, sel:%d\\n' % (old, new, sel))\n          event.Skip()\n\n    def MyFileDialog(self, text, style, mode):\n        dlg = wx.FileDialog(self, \"Give a file name\", self.dirname, self.filename, wildcard, style)\n        if dlg.ShowModal() == wx.ID_OK:\n            self.filename = dlg.GetFilename()\n            self.dirname = dlg.GetDirectory()\n            if mode == \"new\":\n                f = open(os.path.join(self.dirname, self.filename), 'w')\n                self.tab = MyPanel(self.nb, \"\")\n                self.nb.AddPage(self.tab, self.filename, True)\n                self.PushStatusText(text)\n                f.close()\n            elif mode == \"open\":\n                f = open(os.path.join(self.dirname, self.filename), 'r')\n                content = f.read()\n                self.tab = MyPanel(self.nb, content)\n                self.nb.AddPage(self.tab, self.filename, True)\n                f.close()\n                self.PushStatusText(text)\n            elif mode == \"write\":\n                f = open(os.path.join(self.dirname, self.filename), 'w')\n                f.write(self.nb.GetCurrentPage().text.GetValue())\n                f.close()\n                self.PushStatusText(text)\n            else:\n                pass\n        dlg.Destroy()\n\n\n    def SaveCurrentFile(self):\n        return wx.MessageBox(\"Do you want to save the file?\", \"Please confirm\", \n                      wx.ICON_QUESTION | wx.YES_NO, self) == wx.YES\n\n\n\n    #file menu item event handlers.\n    # OnNew method is used to create a new file.\n    def OnNew(self, event):\n        \"\"\" Create a new file\"\"\"\n        if self.nb.GetCurrentPage() is not None:\n            if self.nb.GetCurrentPage().text.IsModified():\n                if self.SaveCurrentFile():\n                    self.OnSave(event)\n        self.MyFileDialog(\"New file Created!\", wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT, \"new\")\n\n\n    def OnOpen(self, event):\n        \"\"\" Open a file\"\"\"\n        if self.nb.GetCurrentPage() is not None: \n            if self.nb.GetCurrentPage().text.IsModified():\n                if self.SaveCurrentFile():\n                    self.OnSave(event)\n        self.MyFileDialog(\"File opened!\", wx.FD_OPEN | wx.FD_FILE_MUST_EXIST, \"open\")\n\n    def OnSave(self, event):\n        \"\"\" Save file\"\"\"\n        if self.nb.GetCurrentPage() is not None:\n            if self.nb.GetCurrentPage().text.IsModified():\n                index = self.nb.GetSelection()\n                f = open(os.path.join(os.getcwd(), self.nb.GetPageText(index)), 'w')\n                f.write(self.nb.GetCurrentPage().text.GetValue())\n                self.nb_changed = False\n                self.PushStatusText(\"File saved!\")\n                f.close()\n\n    def OnSaveAs(self, event):\n        \"\"\" Save a file with a different name\"\"\"\n        self.MyFileDialog(\"File saved!\", wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT, \"write\")\n\n    def OnExit(self, event):\n            self.Close(True)  # Close the frame.\n\n    # edit menu item event handlers        \n    def OnUndo(self, event):\n        self.nb.GetCurrentPage().text.Undo()\n\n    def OnRedo(self, event):\n        self.nb.GetCurrentPage().text.Redo()\n\n    def OnCut(self, event):\n        self.nb.GetCurrentPage().text.Cut()\n\n    def OnCopy(self, event):\n        self.nb.GetCurrentPage().text.Copy()\n\n    def OnPaste(self, event):\n        self.nb.GetCurrentPage().text.Paste()\n    def OnDelete(self, event):\n        self.nb.GetCurrentPage().text.Clear()\n    def OnSelectAll(self, event):\n        self.nb.GetCurrentPage().text.SelectAll()\n\n    # run menu item event handlers\n    def OnVCF(self, event):\n        frame = wx.Frame(None, -1, 'win.py')\n        frame.Show()\n\n    def OnJG(self, event):\n        frame = wx.Frame(None, -1, 'win.py')\n        frame.Show()\n\n\n    # terminal menu item event handlers\n    def OnNewTerminal(self, event):\n        \"\"\" A method to open a new terminal\"\"\"\n        frame = wx.Frame(None, -1, 'win.py')\n        frame.Show()\n\n    def OnCloseTerminal(self, event):\n        \"\"\" A method to close the terminal\"\"\"\n        self.Close(True)\n\n    # Help menu item event handlers\n    def OnAbout(self, event):\n        \"\"\" A method to display the about dialog box\"\"\"\n        dlg = wx.MessageDialog( self, \"AFGI: Augmented Formal Graphical Interface\\nVersion 0.0.1\", \"About AFGI\", wx.OK)\n        dlg.ShowModal() # Show it\n        dlg.Destroy() # finally destroy it when finished.\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.MyFrame.OnAbout","title":"<code>OnAbout(event)</code>","text":"<p>A method to display the about dialog box</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>def OnAbout(self, event):\n    \"\"\" A method to display the about dialog box\"\"\"\n    dlg = wx.MessageDialog( self, \"AFGI: Augmented Formal Graphical Interface\\nVersion 0.0.1\", \"About AFGI\", wx.OK)\n    dlg.ShowModal() # Show it\n    dlg.Destroy() # finally destroy it when finished.\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.MyFrame.OnCloseTerminal","title":"<code>OnCloseTerminal(event)</code>","text":"<p>A method to close the terminal</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>def OnCloseTerminal(self, event):\n    \"\"\" A method to close the terminal\"\"\"\n    self.Close(True)\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.MyFrame.OnNew","title":"<code>OnNew(event)</code>","text":"<p>Create a new file</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>def OnNew(self, event):\n    \"\"\" Create a new file\"\"\"\n    if self.nb.GetCurrentPage() is not None:\n        if self.nb.GetCurrentPage().text.IsModified():\n            if self.SaveCurrentFile():\n                self.OnSave(event)\n    self.MyFileDialog(\"New file Created!\", wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT, \"new\")\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.MyFrame.OnNewTerminal","title":"<code>OnNewTerminal(event)</code>","text":"<p>A method to open a new terminal</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>def OnNewTerminal(self, event):\n    \"\"\" A method to open a new terminal\"\"\"\n    frame = wx.Frame(None, -1, 'win.py')\n    frame.Show()\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.MyFrame.OnOpen","title":"<code>OnOpen(event)</code>","text":"<p>Open a file</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>def OnOpen(self, event):\n    \"\"\" Open a file\"\"\"\n    if self.nb.GetCurrentPage() is not None: \n        if self.nb.GetCurrentPage().text.IsModified():\n            if self.SaveCurrentFile():\n                self.OnSave(event)\n    self.MyFileDialog(\"File opened!\", wx.FD_OPEN | wx.FD_FILE_MUST_EXIST, \"open\")\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.MyFrame.OnSave","title":"<code>OnSave(event)</code>","text":"<p>Save file</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>def OnSave(self, event):\n    \"\"\" Save file\"\"\"\n    if self.nb.GetCurrentPage() is not None:\n        if self.nb.GetCurrentPage().text.IsModified():\n            index = self.nb.GetSelection()\n            f = open(os.path.join(os.getcwd(), self.nb.GetPageText(index)), 'w')\n            f.write(self.nb.GetCurrentPage().text.GetValue())\n            self.nb_changed = False\n            self.PushStatusText(\"File saved!\")\n            f.close()\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.MyFrame.OnSaveAs","title":"<code>OnSaveAs(event)</code>","text":"<p>Save a file with a different name</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>def OnSaveAs(self, event):\n    \"\"\" Save a file with a different name\"\"\"\n    self.MyFileDialog(\"File saved!\", wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT, \"write\")\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.MyPanel","title":"<code>MyPanel</code>","text":"<p>             Bases: <code>Panel</code></p> <p>A class to create a panel for each tab in the notebook</p> <p>Attributes:</p> Name Type Description <code>parent</code> <code>Panel</code> <p>parent panel</p> <code>content</code> <code>str</code> <p>content of the panel</p> <code>text</code> <code>TextCtrl</code> <p>text control to display the content of the panel</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>class MyPanel(wx.Panel): \n    \"\"\"A class to create a panel for each tab in the notebook\n\n    Attributes:\n        parent (wx.Panel): parent panel\n        content (str): content of the panel\n        text (wx.TextCtrl): text control to display the content of the panel\n    \"\"\"\n    def __init__(self, parent, content): \n      super(MyPanel, self).__init__(parent) \n      self.text = wx.TextCtrl(self, style = wx.TE_MULTILINE, value = content, size = wx.Size(800,600)) \n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.RedirectText","title":"<code>RedirectText</code>","text":"<p>             Bases: <code>object</code></p> <p>A class to redirect the output of the console to the text control</p> <p>Attributes:</p> Name Type Description <code>awxTextCtrl</code> <code>TextCtrl</code> <p>text control to which the output is redirected</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>class RedirectText(object):\n    \"\"\"A class to redirect the output of the console to the text control\n\n    Attributes: \n        awxTextCtrl (wx.TextCtrl): text control to which the output is redirected  \n    \"\"\"\n    def __init__(self, aWxTextCtrl):\n        \"\"\"The constructor of the RedirectText class\"\"\"\n        self.out = aWxTextCtrl\n\n    def write(self, string):\n        \"\"\"A method to write the output to the text control \n        Args:\n            string (str): output string\n        Returns:    \n            None\n        \"\"\"\n        self.out.WriteText(string)\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.RedirectText.__init__","title":"<code>__init__(aWxTextCtrl)</code>","text":"<p>The constructor of the RedirectText class</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>def __init__(self, aWxTextCtrl):\n    \"\"\"The constructor of the RedirectText class\"\"\"\n    self.out = aWxTextCtrl\n</code></pre>"},{"location":"reference/#afgi.gui.my_frame.RedirectText.write","title":"<code>write(string)</code>","text":"<p>A method to write the output to the text control  Args:     string (str): output string Returns:       None</p> Source code in <code>src/afgi/gui/my_frame.py</code> <pre><code>def write(self, string):\n    \"\"\"A method to write the output to the text control \n    Args:\n        string (str): output string\n    Returns:    \n        None\n    \"\"\"\n    self.out.WriteText(string)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrorException","title":"<code>YamlToTclErrorException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A class to define the custom exception for the yaml-to-tcl package.  This class inherits from the Exception class.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>The error message.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>class YamlToTclErrorException(Exception):\n    \"\"\"A class to define the custom exception for the yaml-to-tcl package. \n    This class inherits from the Exception class.\n\n    Attributes:\n        message (str): The error message.\n    \"\"\"\n    def __init__(self, message):\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors","title":"<code>YamlToTclErrors</code>","text":"<p>A class to define the custom errors for the yaml-to-tcl package.</p> <p>Methods:</p> Name Description <code>empty_yaml_error</code> <p>A method to define the error message for empty yaml file.</p> <code>invalid_yaml_error</code> <p>A method to define the error message for invalid yaml file.</p> <code>tool_error</code> <p>A method to define the error message for invalid tool name.</p> <code>tool_name_error</code> <p>A method to define the error message for invalid tool name.</p> <code>appmode_error</code> <p>A method to define the error message for invalid appmode name.</p> <code>read_file_error</code> <p>A method to define the error message for invalid read_file name.</p> <code>read_file_top_error</code> <p>A method to define the error message for invalid top module name.</p> <code>read_file_format_error</code> <p>A method to define the error message for invalid RTL format.</p> <code>read_file_filelist_error</code> <p>A method to define the error message for invalid RTL filelist.</p> <code>clock_error</code> <p>A method to define the error message for invalid clock name.</p> <code>clock_name_error</code> <p>A method to define the error message for invalid clock name.</p> <code>clock_period_error</code> <p>A method to define the error message for invalid clock period.</p> <code>reset_error</code> <p>A method to define the error message for invalid reset name.</p> <code>reset_name_error</code> <p>A method to define the error message for invalid reset name.</p> <code>reset_sense_error</code> <p>A method to define the error message for invalid reset sense.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>class YamlToTclErrors:\n   \"\"\"A class to define the custom errors for the yaml-to-tcl package.\n\n    Methods:\n        empty_yaml_error: A method to define the error message for empty yaml file.\n        invalid_yaml_error: A method to define the error message for invalid yaml file.\n        tool_error: A method to define the error message for invalid tool name.\n        tool_name_error: A method to define the error message for invalid tool name.\n        appmode_error: A method to define the error message for invalid appmode name.\n        read_file_error: A method to define the error message for invalid read_file name.\n        read_file_top_error: A method to define the error message for invalid top module name.\n        read_file_format_error: A method to define the error message for invalid RTL format.\n        read_file_filelist_error: A method to define the error message for invalid RTL filelist.\n        clock_error: A method to define the error message for invalid clock name.\n        clock_name_error: A method to define the error message for invalid clock name.\n        clock_period_error: A method to define the error message for invalid clock period.\n        reset_error: A method to define the error message for invalid reset name.\n        reset_name_error: A method to define the error message for invalid reset name.\n        reset_sense_error: A method to define the error message for invalid reset sense.\n    \"\"\"\n   def __init__(self):\n       \"\"\"Constructor for the YamlToTclErrors class.\"\"\"\n       pass\n   def empty_yaml_error (self):\n        \"\"\" A method to define the error message for empty yaml file.\"\"\"\n        return \"Empty Yaml file passed!!\"\n\n   def invalid_yaml_error (self):\n        \"\"\" A method to define the error message for invalid yaml file.\"\"\"\n        return \"Invalid YAML file passed!!\"\n\n   def tool_error (self):\n        \"\"\" A method to define the error message for invalid tool name.\"\"\"\n        return \"Tool value None!\"\n\n   def tool_name_error (self):\n        \"\"\" A method to define the error message for invalid tool name.\"\"\"\n        return \"Unsupported tool name!\"\n\n   def appmode_error(self):\n        \"\"\" A method to define the error message for invalid appmode name.\"\"\"\n        return \"Tool appmode value None!\"\n\n   def read_file_error(self):\n        \"\"\" A method to define the error message for invalid read_file name.\"\"\"\n        return \"read_file value None!\"\n\n   def read_file_top_error (self):\n        \"\"\" A method to define the error message for invalid top module name.\"\"\"\n        return \"RTL top module value None!\"\n\n   def read_file_format_error (self):\n        \"\"\" A method to define the error message for invalid RTL format.\"\"\"\n        return \"RTL format value None!\"\n\n   def read_file_filelist_error (self):\n        \"\"\" A method to define the error message for invalid RTL filelist.\"\"\"\n        return \"RTL filelist value None!\"\n\n   def clock_error (self):\n        \"\"\" A method to define the error message for invalid clock name.\"\"\"\n        return \"Clock value None!\"\n\n   def clock_name_error (self):\n        \"\"\" A method to define the error message for invalid clock name.\"\"\"\n        return \"Clock name value None!\"\n\n   def clock_period_error (self):\n        \"\"\" A method to define the error message for invalid clock period.\"\"\"\n        return \"Clock period value None!\"\n\n   def reset_error (self):\n        \"\"\" A method to define the error message for invalid reset name.\"\"\"\n        return \"Reset value None!\"\n\n   def reset_name_error (self):\n        \"\"\" A method to define the error message for invalid reset name.\"\"\"\n        return \"Reset name value None!\"\n\n   def reset_sense_error (self):\n        \"\"\" A method to define the error message for invalid reset sense.\"\"\"\n        return \"Reset sense value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for the YamlToTclErrors class.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructor for the YamlToTclErrors class.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.appmode_error","title":"<code>appmode_error()</code>","text":"<p>A method to define the error message for invalid appmode name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def appmode_error(self):\n     \"\"\" A method to define the error message for invalid appmode name.\"\"\"\n     return \"Tool appmode value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.clock_error","title":"<code>clock_error()</code>","text":"<p>A method to define the error message for invalid clock name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def clock_error (self):\n     \"\"\" A method to define the error message for invalid clock name.\"\"\"\n     return \"Clock value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.clock_name_error","title":"<code>clock_name_error()</code>","text":"<p>A method to define the error message for invalid clock name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def clock_name_error (self):\n     \"\"\" A method to define the error message for invalid clock name.\"\"\"\n     return \"Clock name value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.clock_period_error","title":"<code>clock_period_error()</code>","text":"<p>A method to define the error message for invalid clock period.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def clock_period_error (self):\n     \"\"\" A method to define the error message for invalid clock period.\"\"\"\n     return \"Clock period value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.empty_yaml_error","title":"<code>empty_yaml_error()</code>","text":"<p>A method to define the error message for empty yaml file.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def empty_yaml_error (self):\n     \"\"\" A method to define the error message for empty yaml file.\"\"\"\n     return \"Empty Yaml file passed!!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.invalid_yaml_error","title":"<code>invalid_yaml_error()</code>","text":"<p>A method to define the error message for invalid yaml file.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def invalid_yaml_error (self):\n     \"\"\" A method to define the error message for invalid yaml file.\"\"\"\n     return \"Invalid YAML file passed!!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.read_file_error","title":"<code>read_file_error()</code>","text":"<p>A method to define the error message for invalid read_file name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def read_file_error(self):\n     \"\"\" A method to define the error message for invalid read_file name.\"\"\"\n     return \"read_file value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.read_file_filelist_error","title":"<code>read_file_filelist_error()</code>","text":"<p>A method to define the error message for invalid RTL filelist.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def read_file_filelist_error (self):\n     \"\"\" A method to define the error message for invalid RTL filelist.\"\"\"\n     return \"RTL filelist value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.read_file_format_error","title":"<code>read_file_format_error()</code>","text":"<p>A method to define the error message for invalid RTL format.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def read_file_format_error (self):\n     \"\"\" A method to define the error message for invalid RTL format.\"\"\"\n     return \"RTL format value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.read_file_top_error","title":"<code>read_file_top_error()</code>","text":"<p>A method to define the error message for invalid top module name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def read_file_top_error (self):\n     \"\"\" A method to define the error message for invalid top module name.\"\"\"\n     return \"RTL top module value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.reset_error","title":"<code>reset_error()</code>","text":"<p>A method to define the error message for invalid reset name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def reset_error (self):\n     \"\"\" A method to define the error message for invalid reset name.\"\"\"\n     return \"Reset value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.reset_name_error","title":"<code>reset_name_error()</code>","text":"<p>A method to define the error message for invalid reset name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def reset_name_error (self):\n     \"\"\" A method to define the error message for invalid reset name.\"\"\"\n     return \"Reset name value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.reset_sense_error","title":"<code>reset_sense_error()</code>","text":"<p>A method to define the error message for invalid reset sense.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def reset_sense_error (self):\n     \"\"\" A method to define the error message for invalid reset sense.\"\"\"\n     return \"Reset sense value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.tool_error","title":"<code>tool_error()</code>","text":"<p>A method to define the error message for invalid tool name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def tool_error (self):\n     \"\"\" A method to define the error message for invalid tool name.\"\"\"\n     return \"Tool value None!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.errors.YamlToTclErrors.tool_name_error","title":"<code>tool_name_error()</code>","text":"<p>A method to define the error message for invalid tool name.</p> Source code in <code>src/afgi/yaml_to_tcl/errors.py</code> <pre><code>def tool_name_error (self):\n     \"\"\" A method to define the error message for invalid tool name.\"\"\"\n     return \"Unsupported tool name!\"\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen.load_yaml_file","title":"<code>load_yaml_file(input_file)</code>","text":"<p>Check if a YAML file is valid.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>A path to the YAML file to be loaded.</p> required <p>Returns:</p> Name Type Description <code>file_name</code> <code>str</code> <p>A dictionary containing the YAML file content.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; load_yaml_file('example.yaml')\n{'task: blah', 'tool': 'VC-Formal', 'appmode': 'FPV', 'task': 'verify', 'read_file': {'top': 'top', 'format': 'sv', 'filelist': 'filename'}, 'clock': {'name': 'clk', 'period': '10ns'}, 'reset': {'name': 'rst', 'sense': 'high'}}\n</code></pre> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen.py</code> <pre><code>def load_yaml_file(input_file):\n    \"\"\"Check if a YAML file is valid.\n\n    Args:\n        input_file (str): A path to the YAML file to be loaded.\n\n    Returns:\n        file_name (str): A dictionary containing the YAML file content.\n\n    Examples:\n        &gt;&gt;&gt; load_yaml_file('example.yaml')\n        {'task: blah', 'tool': 'VC-Formal', 'appmode': 'FPV', 'task': 'verify', 'read_file': {'top': 'top', 'format': 'sv', 'filelist': 'filename'}, 'clock': {'name': 'clk', 'period': '10ns'}, 'reset': {'name': 'rst', 'sense': 'high'}}\n    \"\"\"\n    # Check if file exists\n    if not os.path.isfile(input_file):\n        raise FileNotFoundError(f'File {input_file} not found.')\n\n    # Check if file is empty\n    if os.stat(input_file).st_size == 0:\n        yaml_exception = YamlToTclErrors()\n        raise YamlToTclErrorException(yaml_exception.empty_yaml_error())\n\n    # Check if file is a valid YAML file\n    try:\n        with open(input_file, 'r') as stream:\n           dic = yaml.safe_load(stream)\n           return dic\n    except yaml.YAMLError as exc:\n        print(exc)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen.tcl_gen","title":"<code>tcl_gen(input_file)</code>","text":"<p>Generate TCL file (for either VCF or JG) from YAML configuration. Args:     input_file :  A YAML file containing the configuration for either the VC Formal tool or the JasperGold tool.   Returns:     A TCL file generated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; translate({'task': 'verify', 'tool': 'VC-Formal', 'appmode': 'FPV', 'read_file': {'top': 'top', 'format': 'sv', 'filelist': 'filename'}, 'clock': {'name': 'clk', 'period': '10ns'}, 'reset': {'name': 'rst', 'sense': 'high'}})\n#! /usr/bin/tclsh \n# Generated on 2023-08-01 12:00:00.000000\n# verify\nset_app_mode FPV\n</code></pre> <p>read_file -top top -format sv -sva -vcs \"-f filename\" -assert svaext -lca</p> <p>set_clock -name clk -period 10ns</p> <p>set_reset -name rst -sense high</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen.py</code> <pre><code>def tcl_gen(input_file):\n        \"\"\"Generate TCL file (for either VCF or JG) from YAML configuration.\n            Args:\n                input_file :  A YAML file containing the configuration for either the VC Formal tool or the JasperGold tool.    \n            Returns:\n                A TCL file generated.\n\n            Examples:\n                &gt;&gt;&gt; translate({'task': 'verify', 'tool': 'VC-Formal', 'appmode': 'FPV', 'read_file': {'top': 'top', 'format': 'sv', 'filelist': 'filename'}, 'clock': {'name': 'clk', 'period': '10ns'}, 'reset': {'name': 'rst', 'sense': 'high'}})\n                #! /usr/bin/tclsh \n                # Generated on 2023-08-01 12:00:00.000000\n                # verify\n                set_app_mode FPV\n\n                read_file -top top -format sv -sva -vcs \"-f filename\" -assert svaext -lca\n\n                set_clock -name clk -period 10ns\n\n                set_reset -name rst -sense high\n        \"\"\"\n        dic = load_yaml_file(input_file)\n        tool = dic['tool'] \n        yaml_exception = YamlToTclErrors()\n\n        if tool == None:\n            raise YamlToTclErrorException(yaml_exception.tool_error())\n        if tool == 'VC-Formal':\n            return tcl_vcf(dic)\n        elif tool == 'JasperGold':\n            return tcl_jg(dic)\n        else: \n            raise YamlToTclErrorException(yaml_exception.tool_name_error())\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen_vcf--task-name","title":"Task name","text":"<p>task: This task is used to run Formal Verification on the design.</p> <p># Tool name   tool: VC-Formal</p> <p># Application mode for the Formal tool   appmode: FPV</p> <p>blackbox:   modules:       - add.v       - sub.v   cells:       - add0       - sub0</p> <p>read_file:   top: adder   format: verilog   filelist:        - adder.v       - adder_tb.v       - mult.v</p> <p>clock:   name: clk   period: 10</p> <p>reset:    name: rst    sense: high</p> <p>check-mode: block</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tcl_gen({'task': 'verify', 'tool': 'VC-Formal', 'appmode': 'FPV', 'read_file': {'top': 'top', 'format': 'sv', 'filelist': 'filename'}, 'clock': {'name': 'clk', 'period': '10ns'}, 'reset': {'name': 'rst', 'sense': 'high'}}) \n#! /usr/bin/tclsh\n# Generated on 2023-12-18 19:57:42.641326\n# This task is used to run Formal Verification on the design.\n</code></pre> <p>set_app_mode FPV</p> <p>set_blackbox -designs { add.v sub.v } set_blackbox -cells { add0 sub0 } read_file -top top -format sv -sva -vcs \"-f filename\" -assert svaext -lca</p> <p>create_clock -name clk -period 10 create_reset -name rst -sense high</p> <p>sim_run -stable sim_save_reset</p> <p>check_fv block</p>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen_vcf.tcl_vcf","title":"<code>tcl_vcf(input_dic)</code>","text":"<p>Generate TCL file (for VC Formal tool) from dictionary object built from YAML configuration.</p> <p>Parameters:</p> Name Type Description Default <code>input_dic</code> <code>dict</code> <p>A dictionary object built from YAML configuration.</p> required <p>Returns:</p> Name Type Description <code>filename</code> <code>str</code> <p>A TCL file generated.</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen_vcf.py</code> <pre><code>def tcl_vcf (input_dic):\n        \"\"\"Generate TCL file (for VC Formal tool) from dictionary object built from YAML configuration.\n\n        Args:\n            input_dic (dict): A dictionary object built from YAML configuration.\n\n        Returns:\n            filename (str): A TCL file generated.\n        \"\"\" \n\n        # output file name\n\n        filename = 'tcl_for_vcf.tcl'\n\n        file = open(filename, 'w+') \n\n        shebang = \"#! /usr/bin/tclsh \\n\"\n        now = \"# Generated on \"+str(datetime.datetime.now())+\"\\n\"\n        task = input_dic['task']\n\n        prelude = shebang + now + \"# \" + task + \"\\n\\n\"\n\n        yaml_exception = YamlToTclErrors()\n        # check if appmode is non empty\n        app_mode = input_dic['appmode']\n        if app_mode == None:\n            raise YamlToTclErrorException(yaml_exception.appmode_error())\n\n        set_app_mode = \"set_app_mode \"+ app_mode +\"\\n\\n\"\n\n        # check if there are modules to be blackboxed\n        blackboxes = \"\"\n        if input_dic['blackbox'] != None:\n            modules = input_dic['blackbox']['modules']\n            if modules != None:\n                blackboxes = blackboxes + \"set_blackbox -designs \"+str(to_tcl_filelist(modules))+\"\\n\"\n            cells = input_dic['blackbox']['cells']\n            if cells != None:\n                blackboxes = blackboxes + \"set_blackbox -cells \"+str(to_tcl_filelist(cells))+\"\\n\"           \n\n        # check if read_file is non empty\n        read_file = input_dic['read_file']\n\n        if read_file == None:\n            raise YamlToTclErrorException(yaml_exception.read_file_error())\n        # Top module\n        top_module = read_file['top']\n        if top_module == None:\n            raise YamlToTclErrorException(yaml_exception.read_file_top_error())\n\n        format = read_file['format']\n\n        # Format of the RTL: sverilog or verilog\n        if format == None:\n            raise YamlToTclErrorException(yaml_exception.read_file_format_error())\n\n        # Filelist: list of RTL files\n        filelist = read_file['filelist']\n        if filelist == None:\n            raise YamlToTclErrorException(yaml_exception.read_file_filelist_error())\n\n        other_opts = \"-assert svaext -lca\"\n\n        read_file = \"read_file -top \"+ str(top_module) + \" -format \"+str(format)+ \" -sva -vcs \\\"-f \" + str(to_tcl_filelist(filelist))+\"\\\" \"+ other_opts +\"\\n\\n\"\n\n        # check if clock is non empty\n        clock = input_dic['clock']\n\n        if clock == None:\n            raise YamlToTclErrorException(yaml_exception.clock_error())\n\n        clock_name = clock['name']\n\n        if clock_name == None:\n            raise YamlToTclErrorException(yaml_exception.clock_name_error())\n\n        period = clock['period']\n\n        if period == None:\n            raise YamlToTclErrorException(yaml_exception.clock_period_error())\n\n        create_clock = \"create_clock -name \"+str(clock_name)+\" -period \"+str(period)+\"\\n\\n\"\n        # check if reset is non empty\n        rst = input_dic['reset']\n\n        if rst == None:\n            raise YamlToTclErrorException(yaml_exception.reset_error())\n\n        rst_name = rst['name']\n\n        if rst_name == None:\n            raise YamlToTclErrorException(yaml_exception.reset_name_error())\n\n        sense = rst['sense']\n\n        if sense == None:\n            raise YamlToTclErrorException(yaml_exception.reset_sense_error())\n\n        create_reset = \"create_reset -name \"+str(rst_name)+\" -sense \"+str(sense)+\"\\n\\n\"\n        sim_run = \"sim_run -stable \\nsim_save_reset \\n\\n\"\n\n        check_mode = input_dic['check-mode']\n        check_fv = \"check_fv \" + check_mode + \"\\n\\n\"\n\n        file.writelines([prelude, set_app_mode, blackboxes, read_file, create_clock, create_reset, sim_run, check_fv])\n        file.close()\n        return(filename)\n</code></pre>"},{"location":"reference/#afgi.yaml_to_tcl.tcl_gen_vcf.to_tcl_filelist","title":"<code>to_tcl_filelist(filelist)</code>","text":"<p>Convert a list of files to a TCL filelist.</p> <p>Parameters:</p> Name Type Description Default <code>filelist</code> <code>list</code> <p>A list of files.</p> required <p>Returns:</p> Name Type Description <code>filelist</code> <code>str</code> <p>A file list in TCL format.</p> Source code in <code>src/afgi/yaml_to_tcl/tcl_gen_vcf.py</code> <pre><code>def to_tcl_filelist(filelist):\n    \"\"\"Convert a list of files to a TCL filelist.\n\n    Args:\n        filelist (list): A list of files.\n\n    Returns:\n       filelist (str): A file list in TCL format.\n    \"\"\"\n    flist = \"{ \"\n    for file in filelist:\n        flist = flist + str(file) + \" \"\n    flist = flist + \"}\"\n    return flist\n</code></pre>"}]}